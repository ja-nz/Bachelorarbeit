<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="assets/fonts/cm/cm.css">
  <link rel="stylesheet" href="assets/css/academic-pub.css">
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#simplicity-and-the-state-of-the-web">Simplicity and the state of the web</a><ul>
<li><a href="#microservices">Microservices</a></li>
</ul></li>
<li><a href="#microservices-1">Microservices</a><ul>
<li><a href="#technical-perspective">Technical perspective</a></li>
</ul></li>
<li><a href="#w3c-specifications">W3C specifications</a><ul>
<li><a href="#custom-elements-w3c">Custom Elements <a href="http://w3c.github.io/webcomponents/spec/custom/">(w3c)</a></a><ul>
<li><a href="#lifecycle-methods">Lifecycle methods</a></li>
<li><a href="#custom-attributes">Custom attributes</a></li>
<li><a href="#customized-build-in-elements">Customized build-in elements</a></li>
</ul></li>
<li><a href="#shadow-dom-w3c">Shadow DOM <a href="http://w3c.github.io/webcomponents/spec/shadow/">(w3c)</a></a><ul>
<li><a href="#slots">Slots</a></li>
<li><a href="#styling">Styling</a></li>
<li><a href="#js-behavior">JS Behavior</a></li>
</ul></li>
<li><a href="#html-templates-w3c">HTML Templates <a href="https://www.w3.org/TR/html5/scripting-1.html#the-template-element">(w3c)</a></a></li>
<li><a href="#html-imports-w3c">HTML Imports <a href="https://www.w3.org/TR/html-imports/">(w3c)</a></a></li>
<li><a href="#appendix-a-custom-events-whatwg">Appendix A: Custom Events <a href="https://dom.spec.whatwg.org/#interface-customevent">(whatwg)</a></a></li>
<li><a href="#appendix-b-web-worker-whatwg">Appendix B: Web Worker <a href="https://html.spec.whatwg.org/multipage/workers.html">(whatwg)</a></a><ul>
<li><a href="#assumptions-about-custom-elements">Assumptions about custom elements</a></li>
</ul></li>
</ul></li>
<li><a href="#progressive-enhancement">Progressive Enhancement</a><ul>
<li><a href="#chapter-about-progressive-enhancement">Chapter about progressive enhancement</a></li>
</ul></li>
</ul>
</nav>
<div id="main">
<h1 id="simplicity-and-the-state-of-the-web">Simplicity and the state of the web</h1>
<blockquote>
<p>Simplicity is prerequisite for reliability. - Edsger W. Dijkstra</p>
</blockquote>
<p>Computers can scale, humans can't. Ever since, a program or complex system made by humans has been constrained by our mental capabilities. Like in the analogy of juggling balls, our brain can just &quot;juggle&quot; a few things at a time. Rich Hickey, the inventor of the programming language <em>Clojure</em> gave an inspirational keynote on the topic of <strong>simplicity</strong>.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> In every sphere of a humans life, simplicity aligns perception with our mental capacities. Understanding the word <strong>simple</strong> alone will outline the this paper on its own.</p>
<p>Derived from the ancient Latin word <strong>simplex</strong>, simple can be understood as &quot;literally, uncompounded or onefold&quot;<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> which points directly to the unidimensional aspect. While complexity describes the multilayered und entangled nature of conditions, simplicity empowers the human brain to reason about issues in a straightforward manner. It certainly has some overlapping's with <em>easy</em>, but while <em>easy</em> is more of a relative nature, simple can be laid out as a objective manner - a goal software development should pursuit and praise.</p>
<p>Software development is undoubtedly rich in complexity and full of subtle pitfalls for the human brain. In a typical scenario, a piece of software evolves over time in one or another <del>opinionated</del> direction. Layers of new abstractions wrestling with old legacy abstractions and mutating objects will get out of control. Subtle bugs start to creep in. Eventually the small piece of software ends up in a highly complected monolith which will determine future design decisions to a painful degree. Any company will be highly determined by the current state trying to &quot;keep the lights on&quot;.</p>
<p>On the other hand, any truly agile system architecture is laid out in a fine-grained manner. As Rich Hickey argues, design decisions should be made under the <strong>impression of extending, substitution, moving, combining and repurposing</strong>. The ability to reason about the program at any given time is crucial for future decisions and implementations. Recalling again the unidimensional nature of simplicity.</p>
<p>The <em>state of the web</em> is certainly a different kind of complex multidimensional beast. &quot;The web&quot; is coined to be meant &quot;everything that runs in the browser&quot;. While simplicity in the backend is mostly a matter of principles, any frontend developer is highly restricted on the entangled nature of the browser platform. Every call to an webpage results in a single <strong>global DOM tree</strong> managed by the browser engine. In the early days of the web a typical static page contained just a bunch of text nodes and some styling. Nowadays a typical webapp contains text nodes, functionality and styling from different resources and is expected to work highly dynamic and frictionless.</p>
<p>In the last four years the average transfer size of a webpage doubled to currently around 2.5 MB.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> Subtracting images, fonts or other content the size of HTML, CSS and JS sums up to a total average of 550 kb. One character weights around 1 byte which means an average webpage is delivering 550.000 character or around 125 pages of single-spaced text. Frederic Filloux calculated the ratio of real content on different newspaper websites and came to the conclusion, that only round about 5-6 % of the transferred characters made for consumption.<span class="citation" data-cites="Filloux2016">(Filloux 2016)</span></p>
<p>Having an 95 % overhead is rather undesirable for both the consumers and creators of the website. Since it's a widespread problem without a single point of failure one can argue the platform itself is the failure. In the recent years many frameworks, libraries and methodologies tried to simplify the way of building user interfaces by scoping assets and design rules into maintainable components. One of the most adopted technique was the <strong>virtual DOM</strong> approach essential ditching the old rule of separated HTML, CSS and JS in favor of <strong>scoped JS components</strong> (containing HTML and CSS). While frameworks are a valid approach to solve the problem they remain highly opinionated.</p>
<p>In 2013 thinkers, creators and browser vendors joined together to propose <em>The Extensible Web Manifesto</em>.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> The claim of the Manifesto is to enhance the current web with new low-level capacities. Those capacities should empower creators of the web to write more declarative code and therefore overcome known bottlenecks and artificial abstractions. Four years later, the new capabilities of JavaScript leapfrogged and many new low-level APIs brought to life. With the new APIs at hand a webdeveloper can create scoped and highly reusable microservices without additional libraries even directly in the browser console.</p>
<p><em>Disclaimer:</em> Currently, many of the new standards proposed throughout this paper can only tried and tested inside Google Chrome or Opera. As the innovation cycle is pretty short it is expected to see those standards go live in all major browsers soon.In the meantime all of those functionalities can be safely <strong>polyfilled</strong>.</p>
<h2 id="microservices">Microservices</h2>
<p>Microserve</p>
<p>untangle the web</p>
<hr />
<p>Betrachtet man andere populäre Webframeworks dieser Zeit, wie beispielsweise React oder Angular, lässt sich ziemlich schnell ein gemeinsames Designpattern ausmachen, wie Komponenten intern ihre Zuständen verwalten. Der Facebook Entwickler Dan Abramov hat dieses dichotome Pattern systematisch erfasst und in zwei Kategorien eingeteilt.</p>
<p>Nach Abramov existieren zum einen Komponenten, die alleine für das <strong>Darstellen von Information</strong> zuständig sind. Diese Komponenten nehmen keinerlei Einfluss auf Informationen oder anderen Komponenten um sich herum. Sie sind im wahrsten Sinne passiv und fremdgesteuert über klar definierte Schnittstellen. Diese Komponenten sind häufig flexibel einsetzbar und hochgradig wiederwerwendbar. Abramov nennt diese Komponenten &quot;Presentational Components&quot;.<span class="citation" data-cites="Abramov2015">(Abramov 2015)</span> Verortet man diese Art von Komponenten innerhalb des <em>MVC Pattern</em>, sind die Komponenten reine <em>View-Elemente</em>.</p>
<p>Im Gegensatz dazu stehen Komponenten, die für die <strong>Verarbeitung von Informationen</strong> zuständig sind. Diese so genannten &quot;Container Components&quot; haben oft einen internen Zustand, den sie verändern können und an ihre Kindkomponenten weiterreichen können.<span class="citation" data-cites="Abramov2015">(Abramov 2015)</span> Im <em>MVC Pattern</em> handelt es sich um die <em>Controller</em>. In der funktionalen Programmiersprache Elm werden diese Elemente <em>Updater</em> genannt, was ihre Funktion noch besser umschreibt.</p>
<p>Ein üblicher eventgesteuerter Webservice setzt sich aus unterschiedlichsten Komponenten zusammen, die wiederum unterschiedlichste Eventlistener &amp; -emitter in sich subsummieren. Diese inhärente Komplexität verlangt geradezu nach einer klaren, deterministischen Struktur des Webservices, die das Zusammenspiel orchestriert. In der Analogie des Orchesters gesprochen, benötigt der Webservice (oder sogar die gesamte Webapplikation) einen Dirigenten, der für die Steuerung verantwortlich ist.</p>
<h1 id="microservices-1">Microservices</h1>
<p>Opening up the case for <em>Browsernative Microservices</em> brings up the question about the concept microservices in general. In fact the concept of microservices has many facets, stretching beyond disciplines and technical boundaries. It lacks a formal standardization but there are certain ideas emergine from this pattern. As a primary source of truth this articles relies on the work of Sam Newman, who has written a comprehensive guide in <em>Building Microservices</em>. The purpose of this section is to match those ideas against the manifestations of web components.</p>
<p>In a nutshell a microservice is a small, autonomous service that works together with other services seamlessly.<span class="citation" data-cites="Newman2015">(Newman 2016, 2)</span> or with the words of Fowler and Lewis: &quot;It is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms,...&quot;<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Microservices incorporate many ideas, like <em>domain-driven design</em> where we try to represent the real world in our code.<span class="citation" data-cites="Newman2015">(Newman 2016, 2)</span> Or making use of <em>continuous delivery</em> for pushing software rapidly through <em>automated deployment</em> mechanisms in production.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> And, last but not least, microservices utilizes the idea of small teams with a lot of product knowledge working mostly autonomous on their very own service with their very own set of tools and techniques.</p>
<h2 id="technical-perspective">Technical perspective</h2>
<p>Shift of paradigms / BFF / Platform agnostic / changes in infrastructure like APIs Databanks / Deployment</p>
<p>Talking about microservices in a browsernative context isn't that far fetched as microservices themselves incorporate many ideas from the web. Exemplary, microservices often communicate via an HTTP request-response with resource API's and lightweight messaging.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Nevertheless, while (server-side) microservices offer wide ranges of technical possibilities, we must take into account that (client-side) browsers come with certain constraints and limitations.</p>
<p>Fowler and Lewis issue a call for using services as components. A component is regarded as a unit of software that is independently replaceable and upgradeable. The main advantage of a component in contrast of library is the possibility of an independent deployment. It aligns perfectly with the main goal of a microservice architecture to strip away most of the dependencies in favour of clean interfaces.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span></p>
<p>Components</p>
<p>First of all, from a technical perspective, a microservice reinforces the <em>Single Responsibility Principle</em> defined by Robert C. Martin: &quot;Gather together those things that change for the same reason and separate those things that change for different reasons.&quot;<span class="citation" data-cites="Martin">(Martin, n.d.)</span> An a way this principle tackles another often cited design principle of the <em>seperation of concerns</em>. Web Components incorporate this principle in multiple ways while still remaining flexible.</p>
<p>Most obvious ist the gathering of all related code under the umbrellar of a single HTML tag. Grouping together HTML, JS and CSS Code in a safe, sandboxed environment exposes the possibility to build more cohesive and understandable services. In the typical global nature of web development those three pillars are separated. This circumstance left the developer switching back and forth between code bases developing a tricky (and sometimes biased) way to glue related parts together.</p>
<p>Secondly, the sub-standard <em>custom elements</em> introduces so called lifecycle methods and a getter/setter interface exposing the functionality to the developer. Event handling, for example, can be registered in place which is much more declarative than assigning event listeners from the outside. Of course, this events can be pushed down to nested tags, allowing an increasingly granular system design. This approach will be explained further in the upcoming sections.</p>
<p>The concept of microservices incooperates not only a technical perspective. Microservice patterns are a product of real-world usage.<span class="citation" data-cites="Newman2015">(Newman 2016, 1)</span> In a real world we typical have to deal with the so called <em>Conway's Law</em>:</p>
<blockquote>
<p>&quot;organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations&quot;. <span class="citation" data-cites="Conway1968">(Conway 1968)</span></p>
</blockquote>
<p>Following this logic any company, whether it is web-related or not, should be devided in units grouped around a destinct business service to optimise the workflow. Fowler and Lewis outlines this approach as an &quot;alignment of business capabilities&quot;<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> While this kind of structure may be true for companies like Google or Amazon, there is a vast majority of companies developing for the web which are grouped around tasks.<span class="citation" data-cites="Issa2016">(Issa 2016)</span> A very common structure is formed by the technology stack (UX Designers, Frontend- &amp; Backend Developers) or by separating teams along the product lifecycle (development, testing, deployment).</p>
<p>Advocators from the microservice approach propose a different model. best described by . Web components are one (but important) way to tie up those diciplines as one component can host a single independent business service. Combined with a flexible backend service these components can be huge gain over the cumbersome functional organizational approach.</p>
<p>The ideas transcending from the microservice approach offers plenty of choices and decisions how to proceed with designing a program or to structure a process.</p>
<h1 id="w3c-specifications">W3C specifications</h1>
<p>For building a native microservice running on the &quot;bare-metal&quot; browser engine requires a bunch of new specifications and assumptions. Most importantly the quasi specification <strong>Web Components</strong> is needed. <em>Web Components</em> is not a real standard. It's an amalgam of APIs from multiple w3c specs which can be used independently, too. A webdeveloper may choose one spec and embrace the freedom in architecture which can be combined with other frameworks/libraries.</p>
<p>Depending on the context, some people argue for only two specs which essentially make it possible to create a scoped component but not caring too much on it's distribution<span class="citation" data-cites="Buchner2016">(Buchner 2016)</span>. Some people prefer the three specs <span class="citation" data-cites="vanKesteren2014">(Kesteren 2014)</span>, but the majority advocating the four specs variant, which is listed on <del>the official</del> <a href="http://webcomponents.org">webcomponents.org</a> website. For the purpose of this article, all four specs will be discussed briefly to provide a rough understanding. It is not meant to cover all bits and pieces.</p>
<h2 id="custom-elements-w3c">Custom Elements <a href="http://w3c.github.io/webcomponents/spec/custom/">(w3c)</a></h2>
<p><em>Custom elements</em> are the fundamental building blocks for web components. Essentially, they provide a way to create custom HTML tags enriched with behavior, design and functionality. An obligatory <strong>HelloWorld</strong> will help to grasp the spec:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">&gt;</span> <span class="va">main</span>.<span class="at">js</span>
<span class="kw">class</span> HelloWorld <span class="kw">extends</span> HTMLElement <span class="op">{</span>
  <span class="at">constructor</span>() <span class="op">{</span>
    <span class="kw">super</span>()<span class="op">;</span> <span class="co">// mandatory!</span>
    <span class="kw">this</span>.<span class="at">onclick</span> <span class="op">=</span> e <span class="op">=&gt;</span> <span class="at">alert</span>(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span>
    <span class="kw">this</span>.<span class="at">addEventListener</span>(...)<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span>
<span class="va">customElements</span>.<span class="at">define</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> HelloWorld)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">&gt; index.html
<span class="kw">&lt;hello-world&gt;</span>say hello<span class="kw">&lt;/hello-world&gt;</span></code></pre></div>
<p>Most obvious, this spec relies on the new <em>ES6 Class Syntax</em> in favor of the original prototype-based inheritance model. &quot;Extending <code>HTMLElement</code> ensures the custom element inherits the entire DOM API and means any properties/methods that you add to the class become part of the element's DOM interface.&quot;<span class="citation" data-cites="Bidelman2016">(Bidelman 2016a)</span> Like any other <em>ES6 class</em>, <em>custom element</em>s can be sub-classed further on with the typical <code>extends</code> inheritance.</p>
<p>The beauty of <em>custom elements</em> comes with the keyword <code>this</code> which points to the element itself. Instead of querying and assigning behavior AFTER creation of the node in question <code>this</code> functionality allows a <strong>declarative programming style</strong>. Assigning functionality happens right in place BEFORE creation or insertion of the DOM. The so called <em>fat-arrow</em> (<code>=&gt;</code>) is just a new feature of ES6 and nothing more than an anonymous <code>function()</code>.</p>
<p>After definition, the element needs to be registered in the new global build-in <code>customElements</code> with an tag name like <code>&lt;hello-world&gt;</code>. Mind the dash inside the tag name to conform the spec. Finally, the new element can go live inside the HTML Document <code>index.html</code>.</p>
<h3 id="lifecycle-methods">Lifecycle methods</h3>
<p>In addition to the <code>constructor()</code>, the spec defines so called <em>lifecycle callbacks</em> for controlling the <strong>behaviour in the DOM</strong>. Many popular frameworks like ReactJS or AngularJS rely on similar approaches:</p>
<ul>
<li><code>connectedCallback()</code><br />
Called upon the time of <em>connecting or upgrading the node</em> which means the moment the node is rendered inside the DOM. Typically this method is called straight after the <code>constructor()</code> on insert. This block of code contains setup code, such as fetching resources or rendering elements according to attributes.<span class="citation" data-cites="Bidelman2016">(Bidelman 2016a)</span> For performance issues it's highly preferable to put much code in here.</li>
<li><code>disconnectedCallback()</code><br />
Called upon the time of <em>node removal</em>. Cleanup code like removing eventListeners or disconnecting websockets can be put here.</li>
<li><code>attributeChangedCallback(attrName, oldVal, newVal)</code><br />
This method provides an <em>Onchange handler</em> that runs for certain attributes called with three values as defined in the signature. It is meant to control an elements' transition from on <code>oldVal</code> to a <code>newVal</code>. Due to performance issues, this callback is only triggered for attributes registered in an <em>observedAttributes</em> array.</li>
<li><code>adoptedCallback()</code><br />
Called when moving the node <em>between documents</em>.</li>
</ul>
<h3 id="custom-attributes">Custom attributes</h3>
<p>As previously mentioned, the custom elements must <code>extend</code> the <code>HTMLElement</code>. Consequently, the new element inherits properties and methods from it (and it's parent <code>Element</code>) and things like <code>id, class, addEventListner, ...</code> run out-of-the-box. Additionally, it is possible to define custom attributes using the <em>custom elements'</em> <strong>getter / setter interface</strong> to steer the behavior of the element.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">&gt;</span> <span class="va">main</span>.<span class="at">js</span>
<span class="kw">class</span> HelloWorld <span class="kw">extends</span> HTMLElement <span class="op">{</span>
  <span class="at">constructor</span>() <span class="op">{</span>...<span class="op">}</span>
  set <span class="at">sayhello</span>(val) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">_hello</span> <span class="op">=</span> val<span class="op">;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">_hello</span>)<span class="op">;</span>
  <span class="op">}</span>
  get <span class="at">sayhello</span>() <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">_hello</span><span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span>)<span class="op">;</span>
<span class="va">customElements</span>.<span class="at">define</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> HelloWorld)<span class="op">;</span>
<span class="co">// Instantiation</span>
<span class="kw">var</span> el <span class="op">=</span> <span class="kw">new</span> <span class="at">HelloWorld</span>()<span class="op">;</span>
<span class="va">el</span>.<span class="at">sayhello</span> <span class="op">=</span> <span class="st">&quot;earth&quot;</span><span class="op">;</span>
<span class="va">el</span>.<span class="at">sayhello</span><span class="op">;</span><span class="co">//&quot;earth&quot;</span></code></pre></div>
<p>While getters and setters work great in the JS world they fail crossing the boundaries to the corresponding HTML node. Declaring <code>&lt;hello-world sayhello=&quot;mars&quot;&gt;&lt;/hello-world&gt;</code> would't work in the previous setup. A common workaround is archived by using the previous mentioned <code>attributeChangedCallback</code> lifecycle method to <strong>reflect changing HTML attributes to JS</strong> and/or map JS attributes to HTML with <code>this.setAttributes(...)</code> respectively. On <strong>insertion time</strong> html attributes might raise their hand with <code>this.hasAttributes(...)</code> and <code>this.getAttributes(...)</code>. Native DOM properties will reflect their values between HTML and JS automatically.<span class="citation" data-cites="HTML">(<em>HTML Living Standard — Last Updated 11 January 2017</em>, n.d., para. 2.6.1)</span></p>
<p>Concluding this section, a reader might already discover the <strong>mental model</strong> behind <em>web compontents</em>. A custom element is similar to a named function where attributes treated as <strong>input variables</strong>. In the hierarchical nature of DOM, input can occur either top-down via assignments and bottom-up via captured events. The same goes true when talking about output. Even though it seems obvious, it might be helpful to keep this point in mind.</p>
<h3 id="customized-build-in-elements">Customized build-in elements</h3>
<p>One aspect didn't mentioned yet is the possibility of creating sub-classes of <strong>build-in elements</strong> by extending the native Interfaces like the <code>HTMLButtonElement</code> interface. While this functionality is perfectly spec'd it is strongly rejected by some browser vendors.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> Most likely the spec will change in future in one or other way on this issue and therefore <strong>customized build-in elements</strong> left out of this paper intentionally.</p>
<h2 id="shadow-dom-w3c">Shadow DOM <a href="http://w3c.github.io/webcomponents/spec/shadow/">(w3c)</a></h2>
<p>The second most important concept of <em>web components</em> rewards to the <em>shadow DOM</em> spec. In terms of complexity this spec outpacing all others by far. A <em>shadow DOM</em> is basically an isolated DOM tree living inside an another (hosting) DOM tree. The spec refers the hosting tree as <em>light DOM tree</em> and the attached DOM as <em>shadow DOM tree</em>. Conceptually, the <em>shadow DOM</em> issues a single important topic in software development: <strong>Encapsulation</strong>. While the first spec <em>custom elements</em> provides a sufficient way to encapsulate JS behavior, <em>shadow DOM</em> coined strongly to in the direction of style encapsulation.</p>
<p>With an ever increasing complexity of an single-page application, the global nature of the DOM creates a daunting situation for code organization and leads over times to highly fragmented bits of CSS and obscure CSS selectors or html wrappers. Of course, this situation lowers code clarity and reusability dramatically. The only solution which won't break with the existing global paradigm effectively is to allow separate pieces of encapsulated code sit on top of the global DOM - introducing the shadowed DOM approach!</p>
<p>Enhancing the previous example the new encapsulated <code>HelloWorld</code> would like this:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">&gt;</span> <span class="va">main</span>.<span class="at">js</span>
<span class="kw">class</span> HelloWorld <span class="kw">extends</span> HTMLElement <span class="op">{</span>
  <span class="at">constructor</span>() <span class="op">{</span>
    ...
    <span class="kw">this</span>.<span class="at">attachShadow</span>(<span class="op">{</span><span class="dt">mode</span><span class="op">:</span> <span class="st">&#39;open&#39;</span><span class="op">}</span>)<span class="op">;</span>
    <span class="va">shadowRoot</span>.<span class="at">innerHTML</span> <span class="op">=</span> <span class="st">&#39;&lt;p&gt;hello&lt;/p&gt;&#39;</span><span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>The new global method <code>attachShadow</code> adds a new document root to the <code>HelloWorld</code> which has the same properties as a normal DOM. Therefore, invoking <code>innerHTML</code> method would fill the new document (fragment) with some arbitrary content. Note that <code>shadowRoot</code> is marked as <strong>open</strong> which ensures that some events can bubble out and outside JS can reach in the new root. Nested children nodes and other content in the light DOM are &quot;shadowed&quot; by the new root and must be invited in by so called <code>slots</code>.</p>
<h3 id="slots">Slots</h3>
<p>Contradicting to the simplified <code>HelloWorld</code> example, a <em>shadow DOM</em> shouldn't contain any <del>valuable</del> content. While technical possible any change of an element would require deeply nested calls from the <em>light DOM</em> to the <em>shadow DOM</em> to update the element in place. That's why <em>shadow DOM</em> should be perceived more as <strong>static HTML template</strong> and provide therefore a kind of internal frame for the render engine. <code>Slots</code> are placeholders for <em>light DOM</em> nodes used to mark the endpoints in question.</p>
<p>Technically, the <em>light DOM</em> nodes are not moved inside the <em>shadow DOM</em>. Their just rendered in place. It's an subtle but important difference towards handling a node. JS behaviour and CSS styles applied in the <em>light DOM</em> will still be valid in the <em>shadow DOM</em>. The render engine literally taking the nodes and putting them inside the <code>slot</code>. This procedure is commonly referred as <strong>flattening</strong> of the DOM trees.</p>
<h4 id="named-slots">Named slots</h4>
<p>A named slot is the preferable way for clear code organization. Taking for example <code>&lt;slot name=&quot;hello&quot;&gt;Drop me a &quot;hello&quot; node&lt;/slot&gt;</code> targets all direct <em>light DOM</em> child nodes of the hosting node matching the slot name like <code>&lt;div slot=&quot;hello&quot;&gt;&lt;/div&gt;</code>. Writing a little documentation inside the <code>&lt;slot&gt;</code> tag is considered as a good practice as it will be rendered only if no matching <em>light DOM</em> node is available. This functionality makes a <em>custom element</em> pretty much self-explanatory.</p>
<h4 id="unnamed-slots">Unnamed slots</h4>
<p>Inside a so-called <em>default slot</em> which looks like <code>&lt;slot&gt;Unnamed content goes here&lt;/slot&gt;</code>, the render engine expands all direct <em>light DOM</em> children without a <code>slot</code> attribute. In case of multiple default slots, the first slot takes it all.</p>
<h3 id="styling">Styling</h3>
<p>As mentioned in the last section, there is a distinct difference about the nature of nodes. Nodes declared and rendered exclusively in the <em>shadow DOM</em> are not affected by any styling from outside. Nodes which are declared outside and distributed via <code>slots</code> will be styled in the <em>light DOM</em> and can be additionally painted in the <em>shadow DOM</em> through the new CSS-Selector <code>::slotted()</code>.</p>
<p>Note that styles from the outside have an higher specify than styles assigned after distribution. Therefore it is generally a good advice to minimize the global stylings to some base styling for uniformity of the web site while leaving the specific stylings to the component. Due to the cascading nature of CSS, styles will still &quot;bleed in&quot; from ancestors to the <em>light DOM</em> nodes. Therefore it's strongly recommended to begin every <em>shadow DOM</em> with a <strong><em>CSS reset:</em> <code>:host {all: initial;}</code></strong>.</p>
<p>Regarding the importance style encapsulation, a couple of new CSS rules emerged that are exclusively targeting the <em>shadow DOM</em>. The table below outlines styling possibilities for the use INSIDE the <em>shadow DOM</em>:</p>
<p>[[ CSS Selectors ]]</p>
<p>Using the <em>functional selector</em> of <code>:host()</code> or even the only-functional <code>:host-contest()</code> allows the creation of <strong>context-aware custom elements</strong>. A possible use case would be &quot;theming&quot; a component (example taken from <span class="citation" data-cites="Bidelman2016shadow">(Bidelman 2016b)</span>):</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">&gt; index.html
<span class="kw">&lt;body</span><span class="ot"> class=</span><span class="st">&quot;darktheme&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;fancy-tabs&gt;</span>
    ...
  <span class="kw">&lt;/fancy-tabs&gt;</span>
<span class="kw">&lt;/body&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css">&gt; fancy-tabs shadowRoot
&lt;style&gt;
<span class="dv">:</span>host-context(<span class="fl">.darktheme</span>) <span class="kw">{</span>
<span class="er"> </span> <span class="kw">color:</span> <span class="dt">white</span><span class="kw">;</span>
<span class="er"> </span> <span class="kw">background:</span> <span class="dt">black</span><span class="kw">;</span>
<span class="kw">}</span>
&lt;/style&gt;</code></pre></div>
<h3 id="js-behavior">JS Behavior</h3>
<p>As mentioned earlier any logic applied to <em>light DOM</em> nodes stays with the node even after redistribution. For the sake of separation of concerns the business logic should be part of the <em>custom element</em> (the <em>light DOM</em>) and not the part of the <em>shadow DOM</em>. On the other hand there are numerous scenarios where JS is just concerned with <strong>styling or animation of an element</strong>.In this case it might be more straightforward to apply JS inside the <em>shadow DOM</em> to avoid mixing with business logic handlers.</p>
<p>Drilling down to a <em>light DOM</em> node from an <em>shadow DOM</em> context is not possible with querying the node directly with <code>.querySelector()</code> or <code>.getElementById()</code> as the node is not part of the context. To get a distributed node in question it needs the way over the slot node and call <code>slot.assinedNodes()</code> to receive an array of distributed node(s) which can be accessed and manipulated like any other node. Calling <code>.assignedNodes()</code> on an empty <code>slot</code> returns an empty array.</p>
<p>Wrapping up this section, <em>shadow DOM</em> provides a non-hacky way to create uniform looking <em>custom elements</em> and even enhance styling possibilities without adding much overhead. Still, for smaller components with only one or two child nodes, just a little styling and/or no structured redistribution a <em>shadow DOM</em> might be to hard to reason about. Eventually it all depends on the question of &quot;how hard is it to implement it without shadow DOM&quot; - which can't be answered universally. For a more in-depth guide, Google Engineer Eric Bidelman wroten a great primer on <em>shadow DOM</em><span class="citation" data-cites="Bidelman2016shadow">(Bidelman 2016b)</span>.</p>
<p>So far, there is still a missing link between <em>light DOM</em> and <em>shadow DOM</em>. The observant reader may have already noticed the weak point in the <code>HelloWorld</code> example: how to &quot;vitalize&quot; the <em>shadow DOM</em>. Recapturing the last <code>HelloWorld</code> example a string of markup was assigned to the <code>shadowRoot.innerHTML</code> property. While it works perfectly fine in this simple case, a string of markup is rather cumbersome and error-prone and doesn't scale well. When putting quotes inside another quotes things break quickly. It makes the life hard for developers to work with it because it requires manual indentation and is out of syntax highlighting. That's the time templates come into play.</p>
<h2 id="html-templates-w3c">HTML Templates <a href="https://www.w3.org/TR/html5/scripting-1.html#the-template-element">(w3c)</a></h2>
<p>Among all other new standards <em>HTML templates</em> are the most mature and adopted standard in the browser environment. All major browsers, except from Internet Explorer, support this standard.</p>
<p>One core concept in templates is efficiency: Whatever dropped inside a <code>template</code> tag <del>bucket</del> will be parsed on runtime - but not constructed into the <em>content tree</em>. It remains plain HTML Markup sitting somewhere in the document until the time of activation.</p>
<p>Activation typically takes four steps:</p>
<ol type="1">
<li><strong>Querying the template node in question</strong><br />
const node = document.querySelector('template');</li>
<li><strong>Parsing the content and preparing the templates' content</strong><br />
const content = node.content;<br />
-&gt; Returns a <em>DocumentFragment</em> object. Handling is straight forward<br />
content.querySelector('img').src = 'logo.png';</li>
<li><strong>Optional: Cloning the <em>DocumentFragment</em> for multiple use</strong><br />
const clone = content.cloneNode(&quot;deep&quot;);</li>
<li><strong>Appending the clone/original to destination</strong><br />
document.body.appendChild(clone);</li>
</ol>
<p>As easy and minimal <em>HTML templates</em> are, they're missing out a crucial feature other template implementations usually have. As templates are basically just dump containers for HTML Markup, there is no way to define some logic as <strong>placeholders</strong> where content should appear. Of course, with heavy use of JS things could be modeled this way. The idiomatic way tends more towards a <em>Shadow DOM &amp; HTML templates</em> symbiosis.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">&gt; index.html
<span class="kw">&lt;hello-world&gt;</span>
  <span class="kw">&lt;p</span><span class="ot"> id=</span><span class="st">&quot;sendto&quot;</span><span class="ot"> slot=</span><span class="st">&quot;placeholder&quot;</span><span class="kw">&gt;</span>
    Hello World Web Component    
  <span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/hello-world&gt;</span>
<span class="co">&lt;!-- COMPONENT STARTS HERE --&gt;</span>
<span class="kw">&lt;template</span><span class="ot"> id=</span><span class="st">&quot;hello&quot;</span><span class="kw">&gt;</span>
  <span class="co">&lt;!-- STYLES --&gt;</span>
  <span class="kw">&lt;style&gt;</span>
    <span class="fl">#stylewrapper</span> <span class="kw">{</span>
      <span class="kw">font-weight:</span> <span class="dt">bold</span><span class="kw">;</span>
      <span class="kw">color:</span> orange<span class="kw">;</span>
    <span class="kw">}</span>
  <span class="kw">&lt;/style&gt;</span>
  <span class="co">&lt;!-- CONTENT --&gt;</span>
  <span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;stylewrapper&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;slot</span><span class="ot"> name=</span><span class="st">&quot;placeholder&quot;</span><span class="kw">&gt;</span>
      Named placeholder
    <span class="kw">&lt;/slot&gt;</span>
  <span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/template&gt;</span>

<span class="kw">&lt;script&gt;</span>
  <span class="co">// Switched to anonymous class notation</span>
  <span class="co">// for keeping associated code together.</span>
  <span class="va">customElements</span>.<span class="at">define</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span>
    <span class="kw">class</span> <span class="kw">extends</span> HTMLElement <span class="op">{</span>
     <span class="at">constructor</span>() <span class="op">{</span>
       <span class="kw">super</span>()<span class="op">;</span>
       <span class="kw">this</span>.<span class="at">attachShadow</span>(<span class="op">{</span><span class="dt">mode</span><span class="op">:</span> <span class="st">&#39;open&#39;</span><span class="op">}</span>)<span class="op">;</span>
       <span class="kw">const</span> template <span class="op">=</span>
         <span class="va">document</span>.<span class="at">querySelector</span>(<span class="st">&#39;#hello&#39;</span>)<span class="op">;</span>
       <span class="kw">this</span>.<span class="at">shadowRoot</span>
         .<span class="at">appendChild</span>(<span class="va">template</span>.<span class="at">content</span>)<span class="op">;</span>
     <span class="op">}</span>
   <span class="op">}</span>)<span class="op">;</span>
<span class="op">&lt;</span><span class="ss">/script&gt;</span></code></pre></div>
<p>The updated <code>HelloWorld</code> component looks already pretty mature. It combines all the previous mentioned standards into one blob of HTML. <em>Custom Elements</em> serves the logic, <em>Shadow DOM</em> scopes the styles and <em>HTML Templates</em> efficiently glues DOM and <em>Shadow DOM</em> together. This separation of concerns comes with a huge gain in flexibility. In a real world scenario <code>HelloWorld</code> would contain/reference multiple <em>HTML Templates</em> and could switch them around without any fuss. A developer might to split up templates into <strong>STYLE</strong> templates and <strong>CONTENT</strong> templates to increase reusability even further.</p>
<p>The last standard in the row of four is not concerned with the internals of a <em>web component</em>. <em>HTML Imports</em> serves the need for an efficient distribution mechanism of components.</p>
<h2 id="html-imports-w3c">HTML Imports <a href="https://www.w3.org/TR/html-imports/">(w3c)</a></h2>
<p>Importing the <code>HelloWorld</code> component is a one-liner:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;link</span><span class="ot"> rel=</span><span class="st">&quot;import&quot;</span><span class="ot"> href=</span><span class="st">&quot;Hello.html&quot;</span><span class="ot"> async</span><span class="kw">&gt;</span></code></pre></div>
<p>The <code>async</code> flag is optional but like in any other fetching event, strongly recommended. Once the imported HTML document comes into scope, activation follows a very similar pattern like the previously mentioned <em>HTML templates</em>:</p>
<ol type="1">
<li><p><strong>Querying the link node</strong></p></li>
<li><p><strong>Parsing the content and preparing the render</strong><br />
const content = linknode.import; -&gt; Unlike the <em>HTML template</em> the content a fully equipped document object.</p></li>
<li><p><strong>Optional: Cloning some nodes for multiple use</strong></p></li>
<li><p><strong>Appending the clone/original to destination</strong></p></li>
</ol>
<p>This again is the imperative way to handle a generic <em>HTML Import</em>. In the declarative world of <em>web components</em> a component is activated, parsed and anchored solely by its' tag name <code>&lt;hello-world&gt;&lt;/hello-world&gt;</code>. Preliminary, the component needs proper configuration as the last <code>HelloWorld</code> example wouldn't work like it is currently. The next section will elaborate the right configuration and composition of a component to work out-of-the-box.</p>
<p>Despite from being just a practical document importer <em>HTML imports</em> acts like a fully fledged dependency manager for the browser. Multiple resources, ranging from stylesheets, scripts, documents, media files and even other <code>imports</code> can be grouped together in a logical <code>import</code> statement. Internally, the browser engine keeps track for every imported resource so it won't be loaded twice. The inherent complexity is in fact a stumbling block for wider browser adoption. Currently only Googles blink web engine supports <em>HTML Imports</em> as they are the driving force behind the <em>web components</em> spec in general. Mozilla and Apple imposed distaste for <em>HTML Imports</em> as a whole. One reason for this can be found in the incompatibility of the spec with the upcoming <em>ES6 module loader</em>.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></p>
<p>Despite the discrepancies among browser vendors <em>HTML Imports</em> should still be part of the paper and future <em>web components</em> as no other native browser technology can bundle up CSS, JS and HTML that efficient. As of today, January 2017, only Googles Chrome and related Opera browser supporting the full <em>web components</em> spec and, despite from <em>HTML Imports</em>, all other browser vendors most likely will catch up with <em>Custom Elements</em> and <em>Shadow DOM</em> within this year. In the meantime, the full <em>web components</em> stack can be <strong>polyfilled</strong> and used across all browsers.</p>
<h2 id="appendix-a-custom-events-whatwg">Appendix A: Custom Events <a href="https://dom.spec.whatwg.org/#interface-customevent">(whatwg)</a></h2>
<p>Events are first-class citizens in the browser world and <em>Custom Events</em> are no exception. The <em>Custom Elements</em> interface is part of the DOM since years but with the rise of <em>Custom Elements</em> they will most likely become an indispensable building block of <em>web components</em>.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">&gt; index.html
<span class="kw">&lt;hello-world&gt;</span>
  <span class="kw">&lt;button&gt;</span>Launch CustomEvent<span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/hello-world&gt;</span>
<span class="co">&lt;!-- COMPONENT STARTS HERE --&gt;</span>
<span class="kw">&lt;script&gt;</span>
  <span class="va">customElements</span>.<span class="at">define</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> 
  <span class="kw">class</span> <span class="kw">extends</span> HTMLElement <span class="op">{</span>
    <span class="at">constructor</span>() <span class="op">{</span>
      <span class="kw">super</span>()<span class="op">;</span>
      <span class="co">// Craft a CustomEvent e</span>
      <span class="kw">const</span> e <span class="op">=</span> <span class="kw">new</span> <span class="at">CustomEvent</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> <span class="op">{</span>
        <span class="dt">bubbles</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span> <span class="co">//important!</span>
        <span class="dt">detail</span><span class="op">:</span> <span class="st">&#39;Contains string or object&#39;</span>
      <span class="op">}</span>)<span class="op">;</span>
      <span class="co">// Launch e on child button click</span>
      <span class="kw">this</span>.<span class="at">addEventListener</span>(<span class="st">&#39;click&#39;</span><span class="op">,</span> click <span class="op">=&gt;</span> <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">dispatchEvent</span>(e)
        <span class="va">click</span>.<span class="at">stopPropagation</span>()<span class="op">;</span>
      <span class="op">}</span>)<span class="op">;</span>
      <span class="co">// Catch e. Typically done by some parent</span>
      <span class="co">// node. Message in detail property</span>
      <span class="kw">this</span>.<span class="at">addEventListener</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> e <span class="op">=&gt;</span> <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>(<span class="va">e</span>.<span class="at">detail</span>)
      <span class="op">}</span>)<span class="op">;</span>
    <span class="op">}</span>
  <span class="op">}</span>)<span class="op">;</span>
<span class="op">&lt;</span><span class="ss">/script&gt;</span></code></pre></div>
<p>Naming events after the emitting tag makes the API almost self-explanatory. Fortunately the <code>detail</code> property can transmit even objects witch allows the developer to craft almost all functionality inside one event. The further sections will elaborate a feasible architecture for building a scaling microservice architecture.</p>
<p>Chaining and aggregating events from child nodes should be practiced and exercised quiet frequently. As mentioned earlier in the <em>Custom Elements</em> section, the pattern of <strong>extending native elements</strong> should be somewhat dismissed as it may be implemented outside of Chrome. Nevertheless, it is possible to create own kind of quasi native buttons when chaining a <em>CustomEvent</em> directly after the native click event.</p>
<p>Another typical <em>custom element</em> use case can be as an actor on (native) child elements. In this case, the <em>Custom Element</em> catches events from children, buffers or rebuild them and eventuall fires an event towards the document root.</p>
<p>Unfortunately events only work &quot;upstream&quot; towards parent nodes. Still the web platform offers plenty of possibilities to talk back to child nodes.</p>
<h2 id="appendix-b-web-worker-whatwg">Appendix B: Web Worker <a href="https://html.spec.whatwg.org/multipage/workers.html">(whatwg)</a></h2>
<p>Like <em>Custom Events</em>, <em>Web Workers</em> had been around for a long time and therefore embrace full support among major browser vendors. They emerged at around 2009 when discussions about browser performance was in the early stages of development. Nevertheless, the addressed problem of <em>Web Workers</em> is a fundamental language problem of JS itself.</p>
<p>JS runs in a single-threaded language environment. Every script in the browser environment, from handling UI events to query and process larget amounts of API data and manipulating the DOM, runs on the same thread<span class="citation" data-cites="Bidelman2010">(Bidelman 2010)</span>. Putting a lot of work to the single main thread can slow down the web service significantly. From time to time scripts can block or fail to whatever reason which leads to a frozen UI on the users side. A worker can overcome the bottleneck of the single-threaded nature with spawning a new <strong>background thread</strong>. Most of the browsers work can be leveraged to this new thread. Todays web architectures aims to leverage an increasing amout of proccessing to the client to avoid time-consuming roundtrips especially in mobiles networks.<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> While many native APIs like <code>fetch</code> work seamlessly in the new thread, a worker has no access to the DOM at all.</p>
<p>A <em>Web Worker</em> spawns a new background thread where scripts can run concurrent to the main thread. Usually a worker is loaded from a workers dedicated file to embrace this kind of separation.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">const</span> worker <span class="op">=</span> <span class="kw">new</span> <span class="at">Worker</span>(<span class="st">&#39;worker.js&#39;</span>)<span class="op">;</span></code></pre></div>
<p>After initialization a worker communicates over a simple <strong>message based interface</strong> with the main thread.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">&gt;</span> <span class="va">main</span>.<span class="at">js</span>
<span class="co">// Send to worker</span>
<span class="va">worker</span>.<span class="at">postMessage</span>(<span class="st">&#39;Hello World&#39;</span>)<span class="op">;</span>
<span class="co">// Receive msg from worker</span>
<span class="va">worker</span>.<span class="at">addEventListener</span>(<span class="st">&#39;message&#39;</span><span class="op">,</span> e <span class="op">=&gt;</span>
  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Worker said: &#39;</span><span class="op">,</span> <span class="va">e</span>.<span class="at">data</span>))<span class="op">;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">&gt;</span> <span class="va">worker</span>.<span class="at">js</span>
<span class="co">// Receive msg and echo back</span>
<span class="kw">this</span>.<span class="at">addEventListener</span>(<span class="st">&#39;message&#39;</span><span class="op">,</span> e <span class="op">=&gt;</span>
  <span class="kw">this</span>.<span class="at">postMessage</span>(<span class="st">&quot;Echo &quot;</span> <span class="op">+</span> <span class="va">e</span>.<span class="at">data</span>))<span class="op">;</span></code></pre></div>
<p>Having no access to the DOM can be seen as hinderance,but i</p>
<p>Macroperspektive / Composition</p>
<h3 id="assumptions-about-custom-elements">Assumptions about custom elements</h3>
<p>Apart from the spec'd perspective there is mental model a webdeveloper might</p>
<p>Creating and using webcomponents might require a new mental model how do design a</p>
<p>containers</p>
<p>http://alistair.cockburn.us/Hexagonal+architecture</p>
<p>MVC Pattern</p>
<p>Pure frontend vs heavy backend</p>
<h1 id="progressive-enhancement">Progressive Enhancement</h1>
<h2 id="chapter-about-progressive-enhancement">Chapter about progressive enhancement</h2>
<p>title: Browsernative Microservices subtitle: Modular web architecture through new W3C specifications author: Jan Peteler, FH Würzburg-Schweinfurt, jan.peteler@student.fhws.de date: Januar 2017 abstract: Building complex web applications nowadays require additional layers of abstraction and often heavily depend on proprietary frameworks. New specifications build right into the browserengine provide a native service API to overcome tricky abstraction constraints. ...</p>
<div id="refs" class="references">
<div id="ref-Abramov2015">
<p>Abramov, Dan. 2015. “Presentational and Container Components – Medium.” <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" class="uri">https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0</a>.</p>
</div>
<div id="ref-Bidelman2010">
<p>Bidelman, Eric. 2010. “The Basics of Web Workers.” <a href="https://www.html5rocks.com/en/tutorials/workers/basics/" class="uri">https://www.html5rocks.com/en/tutorials/workers/basics/</a>.</p>
</div>
<div id="ref-Bidelman2016">
<p>———. 2016a. “Custom elements v1: reusable web components.” <a href="https://developers.google.com/web/fundamentals/primers/customelements/" class="uri">https://developers.google.com/web/fundamentals/primers/customelements/</a>.</p>
</div>
<div id="ref-Bidelman2016shadow">
<p>———. 2016b. “Shadow Dom V1: Self-Contained Web Components.” <a href="https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom" class="uri">https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom</a>.</p>
</div>
<div id="ref-Buchner2016">
<p>Buchner, Daniel. 2016. “Demythstifying Web Components.” <a href="http://www.backalleycoder.com/2016/08/26/demythstifying-web-components/" class="uri">http://www.backalleycoder.com/2016/08/26/demythstifying-web-components/</a>.</p>
</div>
<div id="ref-Conway1968">
<p>Conway, Melvin E. 1968. “How Do Committees Invent?” <a href="http://www.melconway.com/Home/Committees_Paper.html" class="uri">http://www.melconway.com/Home/Committees_Paper.html</a>.</p>
</div>
<div id="ref-Filloux2016">
<p>Filloux, Frederic. 2016. “Bloated Html, the Best and the Worse.” <a href="https://mondaynote.com/bloated-html-the-best-and-the-worse-cac6eb06496d" class="uri">https://mondaynote.com/bloated-html-the-best-and-the-worse-cac6eb06496d</a>.</p>
</div>
<div id="ref-Fowler2014">
<p>Fowler, Martin, and James Lewis. 2014. “Microservices: A Definition of This New Architectural Term,” January. <a href="http://www.martinfowler.com/articles/microservices.html" class="uri">http://www.martinfowler.com/articles/microservices.html</a>.</p>
</div>
<div id="ref-HTML">
<p><em>HTML Living Standard — Last Updated 11 January 2017</em>. n.d. <a href="https://html.spec.whatwg.org/multipage/" class="uri">https://html.spec.whatwg.org/multipage/</a>.</p>
</div>
<div id="ref-Issa2016">
<p>Issa, Ben. 2016. “The Way of the Web.” Polymer Summit 2016. <a href="https://www.youtube.com/watch?v=8ZTFEhPBJEE" class="uri">https://www.youtube.com/watch?v=8ZTFEhPBJEE</a>.</p>
</div>
<div id="ref-vanKesteren2014">
<p>Kesteren, Anne van. 2014. “Mozilla and Web Components: Update.” <a href="https://hacks.mozilla.org/2014/12/mozilla-and-web-components/" class="uri">https://hacks.mozilla.org/2014/12/mozilla-and-web-components/</a>.</p>
</div>
<div id="ref-Martin">
<p>Martin, Robert C. n.d. “The Single Responsibility Principle.” <a href="http://programmer.97things.oreilly.com/wiki/index.php/The_Single_Responsibility_Principle" class="uri">http://programmer.97things.oreilly.com/wiki/index.php/The_Single_Responsibility_Principle</a>.</p>
</div>
<div id="ref-Newman2015">
<p>Newman, Sam. 2016. <em>Building Microservices</em>. O’Reilly Media, Inc. <a href="http://www.ebook.de/de/product/22539693/sam_newmann_building_microservices.html" class="uri">http://www.ebook.de/de/product/22539693/sam_newmann_building_microservices.html</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://www.youtube.com/watch?v=rI8tNMsozo0&amp;t=46s">Rails Conf 2012 Keynote: Simplicity Matters by Rich Hickey</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="http://www.etymonline.com/index.php?term=simple">Etymology Dictionary</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="http://httparchive.org/trends.php">HTTPArchive Trends</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="https://extensiblewebmanifesto.org/">The Extensible Web Manifesto</a><a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>https://github.com/w3c/webcomponents/issues/509<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>https://hacks.mozilla.org/2014/12/mozilla-and-web-components/<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Latency numbers: https://gist.github.com/jboner/2841832<a href="#fnref7">↩</a></p></li>
</ol>
</section>
</div>
</body>
</html>
