<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Jan Peteler, FH Würzburg-Schweinfurt, jan.peteler@student.fhws.de">
  <title>Browsernative Microservices</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="assets/fonts/cm/cm.css">
  <link rel="stylesheet" href="assets/css/academic-pub.css">
</head>
<body>
<header>
<h1 class="title">Browsernative Microservices</h1>
<h1 class="subtitle">Modular web architecture through new W3C specifications</h1>
<h2 class="author">Jan Peteler, FH Würzburg-Schweinfurt, jan.peteler@student.fhws.de</h2>
<h3 class="date">Januar 2017</h3>
</header>
<nav id="TOC">
<ul>
<li><a href="#simplicity-and-the-web">Simplicity and the web</a></li>
<li><a href="#microservices">Microservices</a><ul>
<li><a href="#componentization-via-services">Componentization via Services</a></li>
<li><a href="#organized-around-business-capabilities">Organized around Business Capabilities</a></li>
<li><a href="#smart-endpoints-and-dumb-pipes">Smart endpoints and dumb pipes</a></li>
<li><a href="#decentralized-governance">Decentralized Governance</a></li>
<li><a href="#decentralized-data-management">Decentralized Data Management</a></li>
<li><a href="#infrastructure-automation">Infrastructure Automation</a></li>
<li><a href="#design-for-failure">Design for failure</a></li>
<li><a href="#evolutionary-design">Evolutionary Design</a></li>
</ul></li>
<li><a href="#w3c-specifications">W3C specifications</a><ul>
<li><a href="#custom-elements-w3c">Custom Elements <a href="http://w3c.github.io/webcomponents/spec/custom/">(w3c)</a></a><ul>
<li><a href="#lifecycle-methods">Lifecycle methods</a></li>
<li><a href="#custom-attributes">Custom attributes</a></li>
<li><a href="#customized-build-in-elements">Customized build-in elements</a></li>
</ul></li>
<li><a href="#shadow-dom-w3c">Shadow DOM <a href="http://w3c.github.io/webcomponents/spec/shadow/">(w3c)</a></a><ul>
<li><a href="#slots">Slots</a></li>
<li><a href="#styling">Styling</a></li>
<li><a href="#js-behavior">JS Behavior</a></li>
</ul></li>
<li><a href="#html-templates-w3c">HTML Templates <a href="https://www.w3.org/TR/html5/scripting-1.html#the-template-element">(w3c)</a></a></li>
<li><a href="#html-imports-w3c">HTML Imports <a href="https://www.w3.org/TR/html-imports/">(w3c)</a></a></li>
<li><a href="#appendix-a-custom-events-whatwg">Appendix A: Custom Events <a href="https://dom.spec.whatwg.org/#interface-customevent">(whatwg)</a></a></li>
<li><a href="#appendix-b-web-worker-whatwg">Appendix B: Web Worker <a href="https://html.spec.whatwg.org/multipage/workers.html">(whatwg)</a></a></li>
</ul></li>
<li><a href="#building-an-browsernative-microservice">Building an browsernative microservice</a><ul>
<li><a href="#checkout-microservice">Checkout microservice</a><ul>
<li><a href="#root-container">Root container</a></li>
<li><a href="#presentational-components">Presentational components</a></li>
</ul></li>
</ul></li>
<li><a href="#thinking-further">Thinking further</a></li>
</ul>
</nav>
<div class="abstract">
Abstract - Building complex web applications nowadays require additional layers of abstraction and often heavily depend on proprietary frameworks. New specifications build right into the browserengine provide a native service API to overcome tricky abstraction constraints.
</div>
<div id="main">
<h1 id="simplicity-and-the-web">Simplicity and the web</h1>
<blockquote>
<p>Simplicity is prerequisite for reliability. - Edsger W. Dijkstra</p>
</blockquote>
<p>Computers can scale, humans can't. Ever since a program or complex system made by humans has been constrained by humans mental capabilities. Like in the analogy of juggling balls, our brain can just &quot;juggle&quot; a few things at a time. Rich Hickey, the inventor of the programming language Clojure gave an inspirational keynote on the topic of <strong>simplicity</strong>.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> In every sphere of a humans life, simplicity aligns perception with our mental capacities.</p>
<p>Derived from the ancient Latin word <strong>simplex</strong>, simple can be understood as &quot;literally, uncompounded or onefold&quot;<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> which points directly to the unidimensional aspect. While complexity describes the multilayered und entangled nature of conditions, simplicity empowers the human brain to reason about issues in a straightforward manner. It certainly has some overlapping's with easy, but while easy is more of a relative nature, simple can be laid out as a objective manner and therefore universally applicable.</p>
<p>Software development is undoubtedly rich in complexity and full of subtle pitfalls. In a typical scenario, a piece of software evolves over time in one or another opinionated direction. Layers of new abstractions wrestling with old legacy abstractions and mutation becomes untraceable. Subtle bugs start to creep in. Eventually the small piece of software may end up in a highly complected monolith which will determine future design decisions to a painful degree. Future strategies of the company/organization will be highly determined by the current state in the need of &quot;keeping the lights on&quot;.</p>
<p>On the other side of this dystopian scenario, the truly modular system architecture abandons many of those inconsistencies. The whole system is divided in pluggable parts, object mutation is either traceable or avoided altogether in favor of immutable data structures. As Rich Hickey argues, design decisions should be made under the <strong>impression of extending, substitution, moving, combining and repurposing</strong>. The ability to reason about the program at any given time is crucial for future decisions and implementations. Recalling again the unidimensional nature of simplicity.</p>
<p>Simplicity in &quot;the web&quot;, read as a loose generalization of &quot;everything that runs in the browser&quot;, is certainly a story full of misconceptions and will be explained further along. While simplicity in the backend is mostly a matter of principles and patterns, any browser-based frontend is restricted on the highly deterministic nature of the browser platform.</p>
<p>In the last four years the average transfer size of a webpage doubled to currently around 2.5 MB.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> Subtracting images, fonts or other content the size of HTML, CSS and JS sums up to a total average of 550 kb. One character weights around 1 byte which means an average webpage is delivering 550.000 character or around 125 pages of single-spaced text. Frederic Filloux analyzed the payload on different newspaper websites and came to the conclusion, that only round about 5-6 % of the transferred characters made for human consumption.<span class="citation" data-cites="Filloux2016">(Filloux 2016)</span></p>
<p>Having an 95 % overhead is rather undesirable for both the consumers and creators of the website. Since it's a widespread problem without a single point of failure one can argue the platform itself is the failure. By design, every pageload results in a monolithic DOM tree managed by the browser engine. Whether rendering just a bunch of static text nodes or an ever changing webapp the underlying global nature of the DOM tree remains the same. Every additional piece of code added to the webpage will invisibly add another fold of complexity to this global object.</p>
<p>In an non-deterministic runtime environment, encapsulation and modularization is a typical pattern to make complexity manageable and accommodate future uncertainty.<span class="citation" data-cites="Baldwin2006">(Baldwin and Clark 2006, 1)</span> Since years the average JS payload is steadily rising which can be interpreted as a trend towards more dynamic websites. The demands to the browser platform changed from a static page renderer to a <strong>dynamic UI machine</strong> without changing the underlying architecture significantly. Under the current situation only additional layers of abstraction can wrestle complexity.</p>
<p>In the recent years many <strong>frameworks</strong>, libraries and methodologies approached the global nature of the DOM by scoping assets and design rules into maintainable components. While the DOM can't be scoped, JS can. Many frameworks, like ReactJS, AngularJS or VueJS just to name a few, ditched the old rule of separated HTML, CSS and JS in favor of an additional layer of abstracted JS components (containing content, markup and styling). Quiet often those frameworks mimic a MVC pattern on top of the browser engine which is a reasonable simple design pattern to build graphical user interfaces. While frameworks are a valid approach to build scalable web applications they remain highly opinionated, embody inherent complexity themselves and can change and break over time. Another downside is code inflation which is a crucial point for performance and third-party libraries are no exception on that. A standardized way for creating complex UI interfaces painlessly requires new build-in browser capabilities.</p>
<p>In the year 2013 thinkers, creators and browser vendors joined together to propose <em>The Extensible Web Manifesto</em>.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> The claim of the manifesto was to enhance the current web platforms with new low-level capabilities. Those features should empower creators of the web to write more declarative code and therefore overcome known bottlenecks and artificial abstractions. Four years later, the enhancement of JavaScript leapfrogged and many new low-level APIs brought to life. With this new APIs at hand a vivid web developer can create robust websites with less code and less additional libraries. This paper is an approach to unfold these <strong>browsernative</strong> technologies to create overall simple and resilient <strong>microservices</strong> for the browser</p>
<p><em>Disclaimer:</em> This paper introduces many new browser build-ins with the focus on try and test. As the time of writing, many examples can be tried frictionless in the console of the latest versions of <strong>Google Chrome, Opera and Apple Safari</strong>.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> On Mozilla Firefox technologies work behind a flag and Microsoft Edge implementation is unfortunately far behind. But Browser implementation changes quickly and soon technology adoption won't be an issue. Meanwhile new standards can be used through <strong>polyfills</strong> even on legacy browsers.</p>
<h1 id="microservices">Microservices</h1>
<p>In search of a better, simpler web architecture we might look on already established pattern that proofed to fulfill enterprise needs. Microservices are a good approach for tearing big monolithic systems into fine-grained simple services with explicit defined boundaries. In a nutshell a microservice is a small, autonomous service that works together with other services seamlessly.<span class="citation" data-cites="Newman2015">(Newman 2016, 2)</span> Or with the words of Fowler and Lewis: &quot;... the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API.&quot;<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Just yet at this point a reader might spot some similarities with microservices and the browser-based development: Both wrestling the problem of monolithic architecture and both using lightweight communication mechanisms. In fact, many big companies of &quot;the web&quot; like Amazon or Netflix successfully transformed their monolithic system into a service based system which gives a glimpse of the power behind microservices.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span></p>
<p>Microservices incorporate many ideas from developing scalable software, like <em>domain-driven design</em> where it pursues the incorporation of real world structure in the code.<span class="citation" data-cites="Newman2015">(Newman 2016, 2)</span> Or making use of <em>continuous delivery</em> for pushing software rapidly through <em>automated deployment</em> mechanisms into production.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Furthermore, microservices transcendent the technical perspective and reaches into the team organization. As a primary source of truth this paper relies on the work of Sam Newman, who has written a comprehensive guide called <em>Building Microservices</em> and the work of Fowler and Lewis. The purpose of this section is to gain confidence about the microservices architecture in the context of the browser platform.</p>
<h2 id="componentization-via-services">Componentization via Services</h2>
<p>&quot;A <strong>component</strong> is a unit of software that is independently replaceable and upgradeable.&quot; <span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Components are the building blocks of microservices. And microservices are the building blocks of applications. Essentially the difference between microservices and components is just the level of abstraction. Whether a concrete microservice or a much more generic component, both following pretty much the same principles. Therefore this paper referring to both parts when talking about <strong>services</strong>.</p>
<p>The first principle of services is the <strong>loose coupling principle</strong>: changing and deploying one service shouldn't result in changing other parts of the system.<span class="citation" data-cites="Newman2015">(Newman 2016, 30)</span>. Mutations or shadowed variables, which is happening a lot in CSS, making it hard to keep changes ought to only affect one place in the application. A <em>browsernative microservice</em> therefore pushing encapsulation and avoiding variable mutations outside its scope as much as possible. Practically, CSS will be scoped and JS fosters immutable JS entities and avoids variables leaking into the global namespace preferring the <code>let</code> or <code>const</code> declaration in favor of the old <code>var</code> declaration.</p>
<p>The second principle of services is the <strong>high cohesion principle</strong>: Whether designing a microservice or it's components we want related behavior sit together, and unrelated behavior to sit elsewhere.<span class="citation" data-cites="Newman2015">(Newman 2016, 30)</span> High cohesion can be expressed in a dynamic way as the <em>Single Responsibility Principle</em>: &quot;Gather together those things that change for the same reason and separate those things that change for different reasons.&quot;<span class="citation" data-cites="Martin">(Martin, n.d.)</span> In a very quick and dirty code quality analysis, the quality can be measured just by counting the places changes in the code occur in order to implement a functionality. In an arbitrary MVC system when a <code>button</code> is dropped into the VIEW part, the CONTROLLER needs some adjustment and maybe the MODEL, too. Three places for adjustment is a reasonable easy task for the brain. In the field of browser based development those principle is often violated in the separated entities HTML, JS and CSS. A <em>browsernative microservice</em> aims for combining all of the resources cohesively in a single place and file.</p>
<p>A <em>component for the web</em>, or web component, is <strong>self-contained</strong> which means it embodys all needed functionality to get it's job done. Therefore it has a much better evolution mechanism in the service contracts. Changing functionality won't break other components. A component can progressively enhanced which guarantees functionality throughout different versions.</p>
<p>Using libraries in web development is a common sense. But compared to libraries, a component service offers multiple advantages. A library is only loosely coupled to the implementation and therefore hard to track in functionality. Changing a library may result in an unforeseen amount of time fixing implementations. It is not unusual to see websites embodying different versions of the same library (like with JQuery). Another issue with libraries is dead code elimination which means the process of removing code that is never going to be executed. New build tools for the web, like Webpack 2 or Rollup offer this feature which relies heavily on the static structure on ES6 modules.<span class="citation" data-cites="Rauschmayer2015">(Rauschmayer 2015)</span> Libraries for the browsers are traditionally &quot;shipped&quot; as non static <strong>immediately-invoked functions</strong>. Bootstrapping those is much harder to archive as dead code may be part of the function itself. A <em>webnative microservices</em> should therefore embrace the high cohesion principle and abandon most of the libraries in favor of static ES6 module to lower the amount of dead code and to increase performance especially at the first render.</p>
<p>Another advantage components have over libraries is the more explicit interface.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> While the functionality of a library needs documentation, a component functionality is exposed via the components' signature which comes in the fashion of an HTML element in <em>browsernative microservices</em>. For example, a button component can consume attributes and becomes a primary buttons just by assignment</p>
<p>.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;my-botton</span><span class="ot"> isPrimary</span><span class="kw">&gt;</span>Primary<span class="kw">&lt;/my-botton&gt;</span></code></pre></div>
<h2 id="organized-around-business-capabilities">Organized around Business Capabilities</h2>
<blockquote>
<p>&quot;organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations&quot;. <span class="citation" data-cites="Conway1968">(Conway 1968)</span></p>
</blockquote>
<p>Emphasizing the human factor in microservices is a key feature. Microservices are a product of real-world usage.<span class="citation" data-cites="Newman2015">(Newman 2016, 1)</span> Instead of splitting team structures along the technology stack (UI Experts -&gt; Middleware -&gt; Database) a microservice approach model teams around <strong>business capabilities</strong>.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Consequently every team is capable of planning, designing, implementing, testing and maintaining their very own microservice. Along the technology stack every member gains high competence about the functionality of the service.</p>
<p>Real-world domains tend to be complex and multifaceted. To unfold their complexity, domains can subdivided into <strong>bounded contexts</strong>.<span class="citation" data-cites="Newman2015">(Newman 2016, 31)</span> For example, customer service is a business domain. Customers again have different contexts depending on their demands. One context can be sales, another context could be support. Every context makes different assumptions about the underlying model. Each bounded context draws an explicit interface where it decides what models to share with other contexts.<span class="citation" data-cites="Newman2015">(Newman 2016, 30)</span> Each context can derived into multiple microservices or, talking about <em>Browsernative Microservices</em>, interfaces to the customers.</p>
<p>By assigning service responsibility to a team, the so called <strong>Definition of Done</strong> (DoD) shifts from &quot;accomplishing projects&quot; to &quot;accomplishing products&quot;. This new paradigm not only changes the administrative overhead like budgeting or resource allocation. It creates a kind of responsibility connection from the team to the service. Expectedly, those teams are more motivated within their very own service and exhibit a more sophisticated iteration time.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span></p>
<p>For many companies working in the spheres of the internet the client-side is highly important for their business. In fact, business goals and capabilities can be derived from the front-end needs. The state of the web is not only a story of numerous artifacts, it is also a story of an highly fragmented market along devices, operating systems, differing sizes and functionalities. Different devices again have different assumptions about the technology stack. Splitting teams along the stack results in an slow paced back and forth negotiation for every change to be made. As browser technologies, design guidelines and devices change in a fast paced manner it makes absolutely sense to shift responsibility towards the teams altogether. A <em>browsernative microservice</em> embraces commitment over its whole lifecycle.</p>
<h2 id="smart-endpoints-and-dumb-pipes">Smart endpoints and dumb pipes</h2>
<p>Microservices for the browsers aim for side-effects like changing the UI given to input parameters or emitting browser events. An isolated microservice won't make too much sense after all. To ensure communication between services, flexible yet powerful communication channels must be established.</p>
<p><em>Smart endpoints and dumb pipes</em> is coined to the approach of designing communication mostly decoupled and as cohesive as possible.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> In the analogy to the real world a message channel should look like sending a letter: Two smart endpoints (sender and receiver) and a mostly unified &quot;dumb&quot; letter format and channel. Each endpoint owns it specific domain logic. In the browsernative context we already emphasized the role of presentational components and containers. The &quot;smartness&quot; of presentational components is altering the UI and reacting on users input. The logic of a container follows the idea of an filter in a Unix sense - receiving a request, applying logic as appropriate and producing a response.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span></p>
<p>Cited earlier in this paper microservices often rely on simple HTTP request-response with resource API's and lightweight messaging as communication protocols.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Those technologies highly accessible and widely adopted and most probably usable for a browsernative service. In the implementation part of this paper a reader will explore the combination of RESTish protocols and a lightweight browser message bus in action.</p>
<p>By focusing the service into clear defined business boundaries, it is easier to define a smart API of the service which in our case will be a set of attributes for the HTML element bound to the service.</p>
<h2 id="decentralized-governance">Decentralized Governance</h2>
<p>Microservices are separate entities and decentralization is therefore a meta concept of microservices. Distributed service responsibility owned by the team is one aspect. Gluing independent service bricks to a whole distributed system talking over the network protocols another one.</p>
<p>This distributed nature allows teams to create their own technology stack, tools and services designed in the spirit of language- and platform independence and share their knowledge with other parties.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> In the recent years many big companies like Facebook, Google, Netflix and others followed that spirit and published their ideas and implementations open source. The previously mentioned ReactJS for example is a brainchild of Facebook. In fact, many tools and techniques are byproduct of vital interaction of concrete domain problems and their implementations.</p>
<p>The spirit of freedom can't be applied universally to <em>Browsernative Microservices</em> as the browser and its underlying DOM will be the limitation factor to a certain degree. Talking about the browser, a reader might be tempted to narrowly thinking of the obvious VIEW layer only - which is not true anymore. In the recent years the browser engines grows to a kind of virtual machine: there are connectors to build-in databases, multithreading support, an ever-growing JS build-ins and even speech synthesis. So-called <em>Progressive Web Apps<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></em>, a bunch of criteria for building good browserapps, can achieve a similar look and feel like native apps. Services like NativeScript<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>, effectively compiling &quot;the web&quot; to native code, lower the boundary between native and browser code even further.</p>
<p>JS is the widely accepted language of the web. Nevertheless, a microservice engineering team might choose another language for various reasons. Transpiling languages to JS as target language isn't exotic anymore. Languages like TypeScript, ClojureScript or PureScript compile to JS even exclusively. Once web components hit a critical mass there will be most likely some library support or foreign function interface towards ES6 modules (which are mandatory for the new specifications). With the rise of WebAssembly, a new low-level programming language for the browser, the determination on JS will hypothetical deteriorate and new quasi native languages for the web might gain traction.</p>
<p>Another more real life decentralization aspect derives from the easiness of deployment in a safe, sandboxed environment. Web components virtually ship no overhead or require obscure build tools. This makes them ideal candidates for sharing and open-sourcing. Webcomponents.org<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> is a registry for ready-to-use components of every scale and purpose where for even Google shares a lot of their material design elements.</p>
<h2 id="decentralized-data-management">Decentralized Data Management</h2>
<p>Data Management in Microservice follows the same modular philosophy like the service implementation. As mentioned earlier different bounded contexts make different assumptions of the underlying models. A <em>browsernative microservices</em> takes this idea even further and expands it to the fragmented world of electronic devices. Decentralized decisions about conceptual models demand for decentralized data storage decisions.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Todays web architectures aims to leverage an increasing amout of processing to the client to avoid time-consuming roundtrips especially in mobiles networks.<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> Since network roundtrips are costly it is a good advice to only query as much data as needed and cache as much as possible.</p>
<p>&quot;Microservices prefer letting each service manage its own database.&quot;[Fowler2014] Ben Issa, chief architect of ING Australia emphasizes this pragmatism on APIs in a conference talk. At ING the frontend demands tailor the backend APIs, APIs may be produced automatically and not even Issa knows how many APIs exists.<span class="citation" data-cites="Issa2016">(Issa 2016)</span> They are using a pattern called <strong>backend for frontends</strong> empowering the team working to craft their UI and backend in a one-to-one relationship.<span class="citation" data-cites="Newman2015">(Newman 2016, 72)</span></p>
<p>To see this pattern in the field a reader might have a look at Facebooks GraphQL<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a>. GraphQL is a query language for the frontend. The backend solely replies on the frontend needs. Another well documented example in the field is Cognitects Datomic<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a>, where parts of the database will be reflected to the client. A so-called Transactor ensures ACID compliance.</p>
<p>The simplified microservice example later in this paper assumes a generic build-in API accompanied by build-in frontend components. Instead of gluing frontend and backend together on runtime, the microservice is designed holistically containing both front- and backends. To reduce network calls especially for mobile devices it is a good advice to cache data (f.e. in a global Service Worker). Revamping offline capabilities even further data can be stored in a browser based database like PouchDB. For the sake of simplicity data management won't be explored into depth throughout this paper.</p>
<h2 id="infrastructure-automation">Infrastructure Automation</h2>
<p>In the global nature of web development the development couldn't completely decoupled from the production environment. This circumstance left developers switching back and forth between files developing tricky opinionated (and more often biased) ways to glue related parts together. With scoped components, code blocks can be developed more sane and conveyed into production without headache. Even more, in the scripted environment of the browser this can be implemented rapidly and continuous.</p>
<p>Previously mentioned Ben Issa, described the ING standard workflow. Every component deserves a own <strong>git repo</strong> containing</p>
<ul>
<li>Internationalization conformity (i18n)</li>
<li>Accessibility conformity (a11y)</li>
<li>Tests for the component</li>
<li>Demos of the component</li>
<li>Blueprints to mock the one to one APIs</li>
<li>Docs</li>
</ul>
<p>Every check-in is handled as release candidate and can be independently deployed by a fully automated deployment machinery.<span class="citation" data-cites="Issa2016">(Issa 2016)</span> Even though this example is an opinionated perception it gives a sense of a mature component build for the web. Due to an exhaustive amount of testing and deployment tools for the browser an automated infrastructure shouldn't be a problem.</p>
<h2 id="design-for-failure">Design for failure</h2>
<p>In theory a microservice is designed with a lot of emphasizes on real-time monitoring for both the architectural elements and business relevant metrics.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Due to the modular structure weak points can occur in the orchestration of the services. Testing and automation is a feasible task but failures may occur in another end users setting undetected. Legacy browsers for example remain a problem for enhancing websites with new technologies.</p>
<p>Regarding the evolution of the web, the &quot;next billion&quot; internet users most likely using Android, have decent specs mobile phones, use an evergreen browser but won't have a reliable internet connection.<span class="citation" data-cites="Lawson2016">(Lawson 2016)</span> While <em>Progressive Enhancement</em> was once coined on the principle to build websites both for Browsers with JS and HTML only, the new <em>Progressive Enhancement</em> tends towards an &quot;<strong>offline first</strong>&quot; build principle. A <em>Browsernative Microservice</em> therefore not only tries to cache data as much as possible, it should also bring in a lot of program logic as described in the previous chapters.</p>
<p>Working in a JS heavy infrastructure demands for optimization to avoid unexpected side-effects like the <em>flash of unstyled content (FOUC)</em>. Googles Polymer propagates the a general-purpose <strong>PRLP pattern</strong><a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a>:</p>
<ul>
<li>Push critical resources for the initial route</li>
<li>Render initial route</li>
<li>Pre-cache remaining routes</li>
<li>Lazy-load and create remaining routes on demand</li>
</ul>
<p>Following this pattern a critical resource can detect browser functionalities beforehand and switch to a <strong>polyfill</strong> instead of the latest browser optimized version. After the initial paint, critical resources like top-level microservices or other app logic can be loaded and registered.</p>
<h2 id="evolutionary-design">Evolutionary Design</h2>
<p>Microservices tend to become smaller over time. An evolutionary design approach puts emphasizes on decomposition and scrapping the service. &quot;The key property of a component is the notion of independent replacement and upgradeability.&quot;<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Therefore we can safely change and chop services. Lazy parts of the system which won't change often should be separated from parts undergoing a lot of churn.<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> Parts that needs coupled changes could should be moved together or should be even merged.</p>
<p>This flexible approach fits good in the world of browser based development. In the last decade we have seen a lot of of changes in the way we develop for the web. New approaches like the virtual DOM approach found their way into mainstream web development followed by frameworks and libraries.</p>
<p><em>Browsernative Microservices</em> should be perceived as complementary technology. Contrary to Angular, React and other frameworks they have a strong interop with existing systems and can be used with them together.</p>
<p>Andrew Rota, developer at Wayfair, came up with the idea to compose small web components around a managing React system.<span class="citation" data-cites="Rota2015">(Rota 2015)</span> As web components are native elements there is no difference to use a native <code>button</code> or a native <code>custom-button</code>. With this pattern a web developer can make use of the encapsulated advantages of web components while still making use of the declarative event management from various frameworks. Whatever new framework will be on the rise within the next years, this approach allows rapid decomposition and reassembling towards a new system.</p>
<h1 id="w3c-specifications">W3C specifications</h1>
<p>For building a native microservice running on the &quot;bare-metal&quot; browser engine requires a bunch of new specifications and assumptions. Most importantly the quasi specification <strong>Web Components</strong> is needed. <em>Web Components</em> is not a real standard. It's an amalgam of APIs from multiple w3c specs which can be used independently, too. A webdeveloper may choose one spec and embrace the freedom in architecture which can be combined with other frameworks/libraries.</p>
<p>Depending on the context, some people argue for only two specs which essentially make it possible to create a scoped component but not caring too much on it's distribution<span class="citation" data-cites="Buchner2016">(Buchner 2016)</span>. Some people prefer the three specs <span class="citation" data-cites="vanKesteren2014">(Kesteren 2014)</span>, but the majority advocating the four specs variant, which is listed on <del>the official</del> <a href="http://webcomponents.org">webcomponents.org</a> website. For the purpose of this article, all four specs will be discussed briefly to provide a rough understanding. It is not meant to cover all bits and pieces.</p>
<h2 id="custom-elements-w3c">Custom Elements <a href="http://w3c.github.io/webcomponents/spec/custom/">(w3c)</a></h2>
<p>Custom elements are the fundamental building blocks for web components introducing the <em>Single Responsibility Principle</em> to the browser. In essence, they provide a way to create <strong>custom HTML tags</strong> subsuming behavior, design and functionality. An obligatory <strong>HelloWorld</strong> will give a flavor about the spec:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">&gt;</span> <span class="va">main</span>.<span class="at">js</span>
<span class="kw">class</span> HelloWorld <span class="kw">extends</span> HTMLElement <span class="op">{</span>
 <span class="at">constructor</span>() <span class="op">{</span>
  <span class="kw">super</span>()<span class="op">;</span> <span class="co">// mandatory!</span>
  <span class="kw">this</span>.<span class="at">onclick</span> <span class="op">=</span> e <span class="op">=&gt;</span> <span class="at">alert</span>(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span>
 <span class="op">}</span>
<span class="op">}</span>
<span class="va">customElements</span>.<span class="at">define</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> HelloWorld)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">&gt; index.html
<span class="kw">&lt;hello-world&gt;</span>say hello<span class="kw">&lt;/hello-world&gt;</span></code></pre></div>
<p>This example should be self-explanatory. Notably, custom elements come in the fashion of <em>ES6 Classes</em><a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a> in favor of the normal JavaScript prototype-based inheritance model. This class must inherit the base <code>HTMLElement</code> interface which &quot;ensures the newly created element inherits the entire DOM API and any properties/methods that you add to the class become part of the element's DOM interface.&quot;<span class="citation" data-cites="Bidelman2016">(Bidelman 2016a)</span> Like any other <em>ES6 class</em>, the new element can be specialized further on using the typical <code>extends</code> inheritance.</p>
<p>The beauty of <em>custom elements</em> comes with the keyword <code>this</code> which points to the element itself. Instead of querying and assigning behavior AFTER creation of the node, custom elements ship their functionality PRIOR initialization of the element. The so called <em>fat-arrow</em> (<code>=&gt;</code>) is just a new ES6 syntax feature for an anonymous function declaration.</p>
<p>After declaration, the new HTML element needs to be registered in the global build-in <code>customElements</code> object with an tag name like <code>&lt;hello-world&gt;</code> acting as key to the element. Mind the dash inside the tag name to conform the spec. Finally, the new element can go live inside the HTML Document <code>index.html</code>.</p>
<h3 id="lifecycle-methods">Lifecycle methods</h3>
<p>In addition to the <code>constructor()</code>, the spec defines so called <em>lifecycle callbacks</em> for controlling the <strong>behaviour in the DOM</strong>. Many popular frameworks like ReactJS or AngularJS rely on similar approaches:</p>
<ul>
<li><code>connectedCallback()</code><br />
Called upon the time of <em>connecting or upgrading the node</em> which means the moment the node is rendered inside the DOM. Typically this method is called straight after the <code>constructor()</code> on insert. Typically, this method contains setup code, such as fetching resources or rendering elements according to attributes.<span class="citation" data-cites="Bidelman2016">(Bidelman 2016a)</span> For a fast initial render of the page, it is highly preferable to put many proceedings in favor of the constructor.</li>
<li><code>disconnectedCallback()</code><br />
Called upon the time of <em>node removal</em>. Cleanup code like removing eventListeners or disconnecting websockets can be put here.</li>
<li><code>attributeChangedCallback(attrName, oldVal, newVal)</code><br />
This method provides an <em>Onchange handler</em> that runs for certain attributes called with three values as defined in the signature. It is meant to control an elements' transition from on <code>oldVal</code> to a <code>newVal</code>. Due to performance issues, this callback is only triggered for attributes registered in an <em>observedAttributes</em> array.</li>
<li><code>adoptedCallback()</code><br />
Called when moving the node <em>between documents</em>.</li>
</ul>
<h3 id="custom-attributes">Custom attributes</h3>
<p>As previously mentioned, the custom elements must <code>extend</code> the <code>HTMLElement</code> interface. Therefore, the new element inherits base properties and methods commonly used in all HTML elements like <code>id, class, addEventListner</code> . Additionally, it is possible to define custom attributes using the <em>custom elements'</em> <strong>getter / setter interface</strong> to steer the behavior of the element.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">&gt;</span> <span class="va">main</span>.<span class="at">js</span>
<span class="kw">class</span> HelloWorld <span class="kw">extends</span> HTMLElement <span class="op">{</span>
 <span class="at">constructor</span>() <span class="op">{</span>...<span class="op">}</span>
 set <span class="at">sayhello</span>(val) <span class="op">{</span>
  <span class="kw">this</span>.<span class="at">_hello</span> <span class="op">=</span> val<span class="op">;</span>
  <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">_hello</span>)<span class="op">;</span>
 <span class="op">}</span>
 get <span class="at">sayhello</span>() <span class="op">{</span>
  <span class="cf">return</span> <span class="kw">this</span>.<span class="at">_hello</span><span class="op">;</span>
 <span class="op">}</span>
<span class="op">}</span>)<span class="op">;</span>
<span class="va">customElements</span>.<span class="at">define</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> HelloWorld)<span class="op">;</span>
<span class="co">// Instantiation</span>
<span class="kw">var</span> el <span class="op">=</span> <span class="kw">new</span> <span class="at">HelloWorld</span>()<span class="op">;</span>
<span class="va">el</span>.<span class="at">sayhello</span> <span class="op">=</span> <span class="st">&quot;earth&quot;</span><span class="op">;</span>
<span class="va">el</span>.<span class="at">sayhello</span><span class="op">;</span><span class="co">//&quot;earth&quot;</span></code></pre></div>
<p>Native DOM properties, like <code>id</code> or <code>onclick</code>, reflect their values between HTML and JS.<span class="citation" data-cites="HTML">(<em>HTML Living Standard — Last Updated 11 January 2017</em>, n.d., para. 2.6.1)</span> For example declaring the HTML <code>&lt;hello-world id=&quot;hello&quot;&gt;</code> like this equals to assign the ID in JS like <code>Node.id = &quot;hello&quot;</code>. This behavior won't work out-of-the-box with methods or properties defined setters. For example declaring <code>&lt;hello-world sayhello=&quot;mars&quot;&gt;&lt;/hello-world&gt;</code> would't call the <code>sayhello</code> function in the previous setup.</p>
<p>A common workaround to bind HTML and JS behavior together is archived by using the aforementioned lifecycle method <code>attributeChangedCallback</code> to <strong>bind changing HTML attributes to JS properties</strong> and to map JS attributes to HTML with <code>this.setAttributes(...)</code> respectively. On insertion time HTML attributes might trigger custom JS methods retrieving HTML attributes using <code>this.getAttributes(...)</code> method.</p>
<p>Concluding this section, a reader might already discover the <strong>mental model</strong> behind <em>web compontents</em>. A custom element is similar to a named function where attributes treated as input variables. In the hierarchical nature of DOM, input can occur either top-down via assignments and bottom-up via captured events. The same goes true when talking about output. Even though it seems obvious, it might be helpful to keep this point in mind.</p>
<h3 id="customized-build-in-elements">Customized build-in elements</h3>
<p>One aspect didn't mentioned yet is the possibility of creating sub-classes of build-in elements by extending the native Interfaces like the <code>HTMLButtonElement</code> interface. While this functionality is perfectly spec'd it is strongly rejected by some browser vendors.<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a> Most likely the spec will change in future in one or other way on this issue and therefore customized build-in elements left out of this paper intentionally.</p>
<h2 id="shadow-dom-w3c">Shadow DOM <a href="http://w3c.github.io/webcomponents/spec/shadow/">(w3c)</a></h2>
<p>A <em>shadow DOM</em> is basically an isolated DOM tree living inside an another (hosting) DOM tree. The spec refers the hosting tree as <em>light DOM tree</em> and the attached DOM as <em>shadow DOM tree</em>. Conceptually, the <em>shadow DOM</em> issues a single important topic in software development: <strong>Encapsulation</strong>. While the first spec <em>custom elements</em> provides a sufficient way to encapsulate JS behavior, <em>shadow DOM</em> coined strongly to in the direction of style encapsulation.</p>
<p>With an ever increasing complexity of an single-page application, the global nature of the DOM creates a daunting situation for code organization and leads over times to highly fragmented bits of CSS and obscure CSS selectors or html wrappers. Of course, this situation lowers code clarity and reusability dramatically. The only solution which won't break with the existing global paradigm effectively is to allow separate pieces of encapsulated code sit on top of the global DOM - introducing the shadowed DOM approach!</p>
<p>Enhancing the previous example the new encapsulated <code>HelloWorld</code> would like this:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">&gt;</span> <span class="va">main</span>.<span class="at">js</span>
<span class="kw">class</span> HelloWorld <span class="kw">extends</span> HTMLElement <span class="op">{</span>
 <span class="at">constructor</span>() <span class="op">{</span>
  ...
  <span class="kw">this</span>.<span class="at">attachShadow</span>(<span class="op">{</span><span class="dt">mode</span><span class="op">:</span> <span class="st">&#39;open&#39;</span><span class="op">}</span>)<span class="op">;</span>
  <span class="va">shadowRoot</span>.<span class="at">innerHTML</span> <span class="op">=</span> <span class="st">&#39;&lt;p&gt;hello&lt;/p&gt;&#39;</span><span class="op">;</span>
 <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>The new global method <code>attachShadow</code> adds a new document root to the <code>HelloWorld</code> which has the same properties as a normal DOM. Therefore, invoking <code>innerHTML</code> method would fill the new document (fragment) with some arbitrary content. Note that <code>shadowRoot</code> is marked as <strong>open</strong> which ensures that some events can bubble out and outside JS can reach in the new root. Nested children nodes and other content in the light DOM are &quot;shadowed&quot; by the new root and must be invited in by so called <code>slots</code>.</p>
<h3 id="slots">Slots</h3>
<p>Contradicting to the simplified <code>HelloWorld</code> example, a <em>shadow DOM</em> shouldn't contain any <del>valuable</del> content. While technical possible any change of an element would require deeply nested calls from the <em>light DOM</em> to the <em>shadow DOM</em> to update the element in place. That's why <em>shadow DOM</em> should be perceived more as <strong>static HTML template</strong> and provide therefore a kind of internal frame for the render engine. <code>Slots</code> are placeholders for <em>light DOM</em> nodes used to mark the endpoints in question.</p>
<p>Technically, the <em>light DOM</em> nodes are not moved inside the <em>shadow DOM</em>. Their just rendered in place. It's an subtle but important difference towards handling a node. JS behaviour and CSS styles applied in the <em>light DOM</em> will still be valid in the <em>shadow DOM</em>. The render engine literally taking the nodes and putting them inside the <code>slot</code>. This procedure is commonly referred as <strong>flattening</strong> of the DOM trees.</p>
<h4 id="named-slots">Named slots</h4>
<p>A named slot is the preferable way for clear code organization. Taking for example <code>&lt;slot name=&quot;hello&quot;&gt;Drop me a &quot;hello&quot; node&lt;/slot&gt;</code> targets all direct <em>light DOM</em> child nodes of the hosting node matching the slot name like <code>&lt;div slot=&quot;hello&quot;&gt;&lt;/div&gt;</code>. Writing a little documentation inside the <code>&lt;slot&gt;</code> tag is considered as a good practice as it will be rendered only if no matching <em>light DOM</em> node is available. This functionality makes a <em>custom element</em> pretty much self-explanatory.</p>
<h4 id="unnamed-slots">Unnamed slots</h4>
<p>Inside a so-called <em>default slot</em> which looks like <code>&lt;slot&gt;Unnamed content goes here&lt;/slot&gt;</code>, the render engine expands all direct <em>light DOM</em> children without a <code>slot</code> attribute. In case of multiple default slots, the first slot takes it all.</p>
<h3 id="styling">Styling</h3>
<p>As mentioned in the last section, there is a distinct difference about the nature of nodes. Nodes declared and rendered exclusively in the <em>shadow DOM</em> are not affected by any styling from outside. Nodes which are declared outside and distributed via <code>slots</code> will be styled in the <em>light DOM</em> and can be additionally painted in the <em>shadow DOM</em> through the new CSS-Selector <code>::slotted()</code>.</p>
<p>Note that styles from the outside have an higher specify than styles assigned after distribution. Therefore it is generally a good advice to minimize the global stylings to some base styling for uniformity of the web site while leaving the specific stylings to the component. Due to the cascading nature of CSS, styles will still &quot;bleed in&quot; from ancestors to the <em>light DOM</em> nodes.</p>
<p>Regarding the importance style encapsulation, a couple of new CSS rules emerged that are exclusively targeting the <em>shadow DOM</em>. The table below outlines styling possibilities for the use INSIDE the <em>shadow DOM</em>:</p>
<ul>
<li>::slotted(selector)<br />
Applies to distributed nodes and repaints them after distribution. <code>Slotted</code> won't override outsides styles but can complement them with unset style rules.</li>
<li>:host<br />
The host property will add styles or change inherited ones inside shadow DOM. Using <code>all: initial;</code> will ensure browser defaults only.</li>
<li>:host(condition)<br />
Like the previous one this node will style the shadow DOM but this time based on attributes/conditions assigned to the hosting node.</li>
<li>:host-context(condition)<br />
Like the previous one this node will style the shadow DOM but will look after context set at the host node or even at the host ancestor.</li>
</ul>
<p>Using the <em>functional selector</em> of <code>:host()</code> or even the only-functional <code>:host-contest()</code> allows the creation of <strong>context-aware custom elements</strong>. A possible use case would be &quot;theming&quot; a component (example taken from <span class="citation" data-cites="Bidelman2016shadow">(Bidelman 2016b)</span>):</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">&gt; index.html
<span class="kw">&lt;body</span><span class="ot"> class=</span><span class="st">&quot;darktheme&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;fancy-tabs&gt;</span>
    ...
  <span class="kw">&lt;/fancy-tabs&gt;</span>
<span class="kw">&lt;/body&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css">&gt; fancy-tabs shadowRoot
&lt;style&gt;
<span class="dv">:</span>host-context(<span class="fl">.darktheme</span>) <span class="kw">{</span>
<span class="er"> </span> <span class="kw">color:</span> <span class="dt">white</span><span class="kw">;</span>
<span class="er"> </span> <span class="kw">background:</span> <span class="dt">black</span><span class="kw">;</span>
<span class="kw">}</span>
&lt;/style&gt;</code></pre></div>
<h3 id="js-behavior">JS Behavior</h3>
<p>As mentioned earlier any logic applied to <em>light DOM</em> nodes stays with the node even after redistribution. For the sake of separation of concerns the business logic should be part of the <em>custom element</em> (the <em>light DOM</em>) and not the part of the <em>shadow DOM</em>. On the other hand there are numerous scenarios where JS is just concerned with <strong>styling or animation of an element</strong>.In this case it might be more straightforward to apply JS inside the <em>shadow DOM</em> to avoid mixing with business logic handlers.</p>
<p>Drilling down to a <em>light DOM</em> node from an <em>shadow DOM</em> context is not possible with querying the node directly with <code>.querySelector()</code> or <code>.getElementById()</code> as the node is not part of the context. To get a distributed node in question it needs the way over the slot node and call <code>slot.assinedNodes()</code> to receive an array of distributed node(s) which can be accessed and manipulated like any other node. Calling <code>.assignedNodes()</code> on an empty <code>slot</code> returns an empty array.</p>
<p>Wrapping up this section, <em>shadow DOM</em> provides a non-hacky way to create uniform looking <em>custom elements</em> and even enhance styling possibilities without adding much overhead. Still, for smaller components with only one or two child nodes, just a little styling and/or no structured redistribution a <em>shadow DOM</em> might be to hard to reason about. Eventually it all depends on the question of &quot;how hard is it to implement it without shadow DOM&quot; - which can't be answered universally. For a more in-depth guide, Google Engineer Eric Bidelman wroten a great primer on <em>shadow DOM</em><span class="citation" data-cites="Bidelman2016shadow">(Bidelman 2016b)</span>.</p>
<p>So far, there is still a missing link between <em>light DOM</em> and <em>shadow DOM</em>. The observant reader may have already noticed the weak point in the <code>HelloWorld</code> example: how to &quot;vitalize&quot; the <em>shadow DOM</em>. Recapturing the last <code>HelloWorld</code> example a string of markup was assigned to the <code>shadowRoot.innerHTML</code> property. While it works perfectly fine in this simple case, a string of markup is rather cumbersome and error-prone and doesn't scale well. When putting quotes inside another quotes things break quickly. It makes the life hard for developers to work with it because it requires manual indentation and is out of syntax highlighting. That's the time templates come into play.</p>
<h2 id="html-templates-w3c">HTML Templates <a href="https://www.w3.org/TR/html5/scripting-1.html#the-template-element">(w3c)</a></h2>
<p>Among all other new standards <em>HTML templates</em> are the most mature and adopted standard in the browser environment. All major browsers, except from Internet Explorer, support this standard.</p>
<p>One core concept in templates is efficiency: Whatever dropped inside a <code>template</code> tag <del>bucket</del> will be parsed on runtime - but not constructed into the <em>content tree</em>. It remains plain HTML Markup sitting somewhere in the document until the time of activation.</p>
<p>Activation typically takes four steps:</p>
<ol type="1">
<li><strong>Querying the template node in question</strong><br />
const node = document.querySelector('template');</li>
<li><strong>Parsing the content and preparing the templates' content</strong><br />
const content = node.content;<br />
-&gt; Returns a <em>DocumentFragment</em> object. Handling is straight forward content.querySelector('img').src = 'logo.png';</li>
<li><strong>Optional: Cloning the <em>DocumentFragment</em> for multiple use</strong><br />
const clone = content.cloneNode(&quot;deep&quot;);</li>
<li><strong>Appending the clone/original to destination</strong><br />
document.body.appendChild(clone);</li>
</ol>
<p>As easy and minimal <em>HTML templates</em> are, they're missing out a crucial feature other template implementations usually have. As templates are basically just dump containers for HTML Markup, there is no way to define some logic as <strong>placeholders</strong> where content should appear. Of course, with heavy use of JS things could be modeled this way. The idiomatic way tends more towards a <em>Shadow DOM &amp; HTML templates</em> symbiosis.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">&gt; index.html
<span class="kw">&lt;hello-world&gt;</span>
 <span class="kw">&lt;p</span><span class="ot"> id=</span><span class="st">&quot;sendto&quot;</span><span class="ot"> slot=</span><span class="st">&quot;placeholder&quot;</span><span class="kw">&gt;</span>
  Hello World Web Component  
 <span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/hello-world&gt;</span>

<span class="co">&lt;!-- COMPONENT STARTS HERE --&gt;</span>
<span class="kw">&lt;template</span><span class="ot"> id=</span><span class="st">&quot;hello&quot;</span><span class="kw">&gt;</span>
 <span class="co">&lt;!-- STYLES --&gt;</span>
 <span class="kw">&lt;style&gt;</span>
  <span class="fl">#stylewrapper</span> <span class="kw">{</span>
   <span class="kw">font-weight:</span> <span class="dt">bold</span><span class="kw">;</span>
   <span class="kw">color:</span> orange<span class="kw">;</span>
  <span class="kw">}</span>
 <span class="kw">&lt;/style&gt;</span>
 <span class="co">&lt;!-- CONTENT --&gt;</span>
 <span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;stylewrapper&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;slot</span><span class="ot"> name=</span><span class="st">&quot;placeholder&quot;</span><span class="kw">&gt;</span>
   Named placeholder
  <span class="kw">&lt;/slot&gt;</span>
 <span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/template&gt;</span>

<span class="kw">&lt;script&gt;</span>
 <span class="co">// Switched to anonymous class notation</span>
 <span class="co">// for keeping associated code together.</span>
 <span class="va">customElements</span>.<span class="at">define</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span>
  <span class="kw">class</span> <span class="kw">extends</span> HTMLElement <span class="op">{</span>
   <span class="at">constructor</span>() <span class="op">{</span>
    <span class="kw">super</span>()<span class="op">;</span>
    <span class="kw">this</span>.<span class="at">attachShadow</span>(<span class="op">{</span><span class="dt">mode</span><span class="op">:</span> <span class="st">&#39;open&#39;</span><span class="op">}</span>)<span class="op">;</span>
    <span class="kw">const</span> helloTemplate <span class="op">=</span> <span class="va">document</span>.<span class="at">querySelector</span>(<span class="st">&#39;#hello&#39;</span>)<span class="op">;</span>
    <span class="kw">this</span>.<span class="va">shadowRoot</span>.<span class="at">appendChild</span>(<span class="va">helloTemplate</span>.<span class="at">content</span>)<span class="op">;</span>
   <span class="op">}</span>
  <span class="op">}</span>)<span class="op">;</span>
<span class="op">&lt;</span><span class="ss">/script&gt;</span></code></pre></div>
<p>The updated <code>HelloWorld</code> component looks already pretty mature. It combines all the previous mentioned standards into one blob of HTML. <em>Custom Elements</em> serves the logic, <em>Shadow DOM</em> scopes the styles and <em>HTML Templates</em> efficiently glues DOM and <em>Shadow DOM</em> together. This separation of concerns comes with a huge gain in flexibility. In a real world scenario <code>HelloWorld</code> would contain/reference multiple <em>HTML Templates</em> and could switch them around without any fuss. A developer might to split up templates into <strong>STYLE</strong> templates and <strong>CONTENT</strong> templates to increase reusability even further.</p>
<p>The last standard in the row of four is not concerned with the internals of a <em>web component</em>. <em>HTML Imports</em> serves the need for an efficient distribution mechanism of components.</p>
<h2 id="html-imports-w3c">HTML Imports <a href="https://www.w3.org/TR/html-imports/">(w3c)</a></h2>
<p>Importing the <code>HelloWorld</code> component is a one-liner:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;link</span><span class="ot"> rel=</span><span class="st">&quot;import&quot;</span><span class="ot"> href=</span><span class="st">&quot;Hello.html&quot;</span><span class="ot"> async</span><span class="kw">&gt;</span></code></pre></div>
<p>The <code>async</code> flag is optional but like in any other fetching event, strongly recommended. Once the imported HTML document comes into scope, activation follows a very similar pattern like the aforementioned <em>HTML templates</em>:</p>
<ol type="1">
<li><p><strong>Querying the link node</strong></p></li>
<li><p><strong>Parsing the content and preparing the render</strong><br />
const content = linknode.import; -&gt; Unlike the <em>HTML template</em> the content a fully equipped document object.</p></li>
<li><p><strong>Optional: Cloning some nodes for multiple use</strong></p></li>
<li><p><strong>Appending the clone/original to destination</strong></p></li>
</ol>
<p>This again is the imperative way to handle a generic <em>HTML Import</em>. In the declarative world of <em>web components</em> a component is activated, parsed and anchored solely by its' tag name <code>&lt;hello-world&gt;&lt;/hello-world&gt;</code>. Preliminary, the component needs proper configuration. The next section will elaborate the right configuration and composition of a component to work out-of-the-box.</p>
<p>Despite from being just a practical document importer <em>HTML imports</em> acts like a fully fledged dependency manager for the browser. Multiple resources, ranging from stylesheets, scripts, documents, media files and even other <code>imports</code> can be grouped together in a logical <code>import</code> statement. Internally, the browser engine keeps track for every imported resource so it won't be loaded twice. The inherent complexity is in fact a stumbling block for wider browser adoption. Currently only Googles blink web engine supports <em>HTML Imports</em> as they are the driving force behind the <em>web components</em> spec in general. Mozilla and Apple imposed distaste for <em>HTML Imports</em> as a whole. One reason for this can be found in the incompatibility of the spec with the upcoming <em>ES6 module loader</em>.<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a></p>
<p>Despite the discrepancies among browser vendors <em>HTML Imports</em> should still be part of the paper as no other native browser technology can bundle up CSS, JS and HTML that efficient.</p>
<h2 id="appendix-a-custom-events-whatwg">Appendix A: Custom Events <a href="https://dom.spec.whatwg.org/#interface-customevent">(whatwg)</a></h2>
<p>Events are first-class citizens in the browser world and <em>Custom Events</em> are no exception. The <em>Custom Elements</em> interface is part of the DOM since years but with the rise of <em>Custom Elements</em> they will most likely become an indispensable building block of <em>web components</em>.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">&gt; index.html
<span class="kw">&lt;hello-world&gt;</span>
 <span class="kw">&lt;button&gt;</span>Launch CustomEvent<span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/hello-world&gt;</span>
<span class="co">&lt;!-- COMPONENT STARTS HERE --&gt;</span>
<span class="kw">&lt;script&gt;</span>
 <span class="va">customElements</span>.<span class="at">define</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> 
 <span class="kw">class</span> <span class="kw">extends</span> HTMLElement <span class="op">{</span>
  <span class="at">constructor</span>() <span class="op">{</span>
    <span class="kw">super</span>()<span class="op">;</span>
   <span class="co">// Craft a CustomEvent e</span>
    <span class="kw">const</span> e <span class="op">=</span> <span class="kw">new</span> <span class="at">CustomEvent</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">bubbles</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span> <span class="co">//important!</span>
    <span class="dt">detail</span><span class="op">:</span> <span class="st">&#39;Contains scalar or object&#39;</span>
   <span class="op">}</span>)<span class="op">;</span>
   <span class="co">// Launch e on child button click</span>
   <span class="kw">this</span>.<span class="at">addEventListener</span>(<span class="st">&#39;click&#39;</span><span class="op">,</span> click <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">dispatchEvent</span>(e)
    <span class="va">click</span>.<span class="at">stopPropagation</span>()<span class="op">;</span>
   <span class="op">}</span>)<span class="op">;</span>
   <span class="co">// Catch e. Typically done by some parent</span>
     <span class="co">// node. Message in detail property</span>
   <span class="kw">this</span>.<span class="at">addEventListener</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> e <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="va">e</span>.<span class="at">detail</span>)
   <span class="op">}</span>)<span class="op">;</span>
  <span class="op">}</span>
 <span class="op">}</span>)<span class="op">;</span>
<span class="op">&lt;</span><span class="ss">/script&gt;</span></code></pre></div>
<p>Naming events after the emitting tag makes the API almost self-explanatory. The <code>detail</code> property can be loaded with primitives as well as objects. The further sections will elaborate a feasible architecture for building a scaling microservice architecture.</p>
<p>Chaining and aggregating events from child nodes should be practiced and exercised quiet frequently. As mentioned earlier in the <em>Custom Elements</em> section, the pattern of <strong>extending native elements</strong> should be somewhat dismissed as it may never implemented outside of Chrome. Nevertheless, it is possible to create own kind of quasi native buttons when chaining a <em>CustomEvent</em> directly after the native click event.</p>
<p>Another typical <em>custom element</em> use case can be as an actor on (native) child elements. In this case, the <em>Custom Element</em> catches events from children, buffers or rebuild them and eventually fires an event towards the document root.</p>
<p>Unfortunately events only work &quot;upstream&quot; towards parent nodes. Still the web platform offers plenty of possibilities to talk back to child nodes.</p>
<h2 id="appendix-b-web-worker-whatwg">Appendix B: Web Worker <a href="https://html.spec.whatwg.org/multipage/workers.html">(whatwg)</a></h2>
<p>Like <em>Custom Events</em>, <em>Web Workers</em> had been around for a long time and therefore enjoy full support among major browsers. They emerged at around 2009 when discussions about browser performance was still in the early days. Nevertheless, the addressed problem of <em>Web Workers</em> is a fundamental language problem of JS itself.</p>
<p>JS runs in a single-threaded language environment. Every script in the browser environment, from handling UI events to query and process larget amounts of API data and manipulating the DOM, runs on the same thread<span class="citation" data-cites="Bidelman2010">(Bidelman 2010)</span>. Putting a lot of work to the single main thread can slow down the web service significantly. From time to time scripts can block or fail for whatever reason which leads to a frozen or crashed UI. A worker can overcome the bottleneck of the single-threaded nature with spawning new <strong>background threads</strong> which allows the UI to stay responsive even when computation-heavy tasks should be carried out. Furthermore, a worker thread adds a performance advantage embracing the multi core CPU architecture most devices running on today. To grasp the full potential of workers, a reader might dive deeper into the Angular 2 architecture, where most of the application layer is abstracted from the main rendering thread into worker threads.<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a></p>
<p>A <em>Web Worker</em> spawns a new background thread where scripts can run concurrent to the main thread. Usually a worker is loaded from a workers dedicated file to embrace this kind of separation.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">const</span> worker <span class="op">=</span> <span class="kw">new</span> <span class="at">Worker</span>(<span class="st">&#39;worker.js&#39;</span>)<span class="op">;</span></code></pre></div>
<p>After initialization a worker communicates over a simple <strong>message based interface</strong> with the main thread.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">&gt;</span> <span class="va">main</span>.<span class="at">js</span>
<span class="co">// Send to worker</span>
<span class="va">worker</span>.<span class="at">postMessage</span>(<span class="st">&#39;Hello World&#39;</span>)<span class="op">;</span>
<span class="co">// Receive msg from worker</span>
<span class="va">worker</span>.<span class="at">addEventListener</span>(<span class="st">&#39;message&#39;</span><span class="op">,</span> e <span class="op">=&gt;</span>
 <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Worker said: &#39;</span><span class="op">,</span> <span class="va">e</span>.<span class="at">data</span>))<span class="op">;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">&gt;</span> <span class="va">worker</span>.<span class="at">js</span>
<span class="co">// Receive msg and echo back</span>
<span class="kw">this</span>.<span class="at">addEventListener</span>(<span class="st">&#39;message&#39;</span><span class="op">,</span> e <span class="op">=&gt;</span>
 <span class="kw">this</span>.<span class="at">postMessage</span>(<span class="st">&quot;Echo &quot;</span> <span class="op">+</span> <span class="va">e</span>.<span class="at">data</span>))<span class="op">;</span></code></pre></div>
<h1 id="building-an-browsernative-microservice">Building an browsernative microservice</h1>
<p>After getting confidence in microservice principles and technical background the paper should bring them both together to form a <em>browsernative microservices</em>. Needless to say the described example is overall simplified to only illustrate the connection between browsernative technologies and microservice patterns. Googles library Polymer is a good place for learning about web components in depth and make use of their simple command line tools. One of their most famous proof of concept is the so-called <a href="https://shop.polymer-project.org/">Polymer Shop</a> which is a fully-fledged online shop nested within a single root element <code>&lt;shop-app&gt;</code>. This app made of several main views and many more invisible custom elements for routing, service worker caching, theming, etc. The whole shop runs as a single application only fetching and sending resources and switching views. Let's assume we work in a sales engineering team of the Polymer Shop and need to rebuild the checkout microservice.</p>
<p>The current checkout can be found at https://shop.polymer-project.org/checkout. Currently the checkout is a single, 671 lines of code long Polymer component incorporation all required fields for sign in, shipping, billing and summarizing the order. In the spirit of microservices we will split up the microservice into fine grained components. The shopping cart data is pulled out of a local storage JSON entity set up previously by another custom-element. Another in-memory opportunity is storing the data in the build-in database IndexedDB.</p>
<h2 id="checkout-microservice">Checkout microservice</h2>
<p>Like a usual checkout this example has 3 to 4 steps:</p>
<ol type="1">
<li>Sign in or Sign up</li>
<li>Shipping details</li>
<li>Payment details</li>
<li>Review and place order</li>
</ol>
<p>Translated into a raw <strong>Custom Element</strong> HTML structure, the top-level microservice might look like the following snippet:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">&gt;shop-checkout.html
<span class="kw">&lt;shop-checkout&gt;</span>
  <span class="kw">&lt;sign-in&gt;&lt;/sign-in&gt;</span>
  <span class="kw">&lt;shipping-details&gt;&lt;/shipping-details&gt;</span>
  <span class="kw">&lt;payment-details&gt;&lt;/payment-details&gt;</span>
  <span class="kw">&lt;place-order&gt;&lt;/place-order&gt;</span>
<span class="kw">&lt;/shop-checkout&gt;</span></code></pre></div>
<p>Yet already we see the simplicity arouse from web components as they persue a clear structure. Each of the child components should act independently over other child nodes utilizing the loose coupling principle. Each child ships all the HTML, CSS and JS code needed to fulfil its work following the high cohesion principle. Each component may contain different views to accommodate different bounded contexts resulting from different devices. And last but not least, all of them communicate over an unobstrusive message bus via the service root component <code>shop-checkout</code>.</p>
<p>Before diving deeper into implementation, its worth to clarify the <strong>architectural pattern</strong> behind components. Any reader of the paper came across ReactJS / Redux, the concept of components may look familiar. Dan Abramov, the creator of Redux, once defined a simple dichotomous pattern for creating UI components. Firstly, he came up with the idea of <strong>presentational components</strong> only related with the concern about <em>how things look</em>. This component literally doesn't know anything about the service in question which makes the component highly flexible and reusable. They are controlled solely from the outside, receiving data and dispatching unbiased events on user interaction.<span class="citation" data-cites="Abramov2015">(Abramov 2015)</span> Most probably every presentational component embodies more HTML/CSS markup and less JS code. It should encapsulate its styles from bleeding out and protect its styles being overwritten. Furthermore, it may contain several templates to change it's look on different demands.</p>
<p>Secondly, Abramov described components he refers as <strong>containers</strong>. A container component is concerned with <em>how things work</em>.<span class="citation" data-cites="Abramov2015">(Abramov 2015)</span> Containers acts as invisible wrappers around presentational components acting more in the sense of UNIX filters. Their job is to fetch data from child nodes, aggregating events, interacting with the model and push state back to the presentational components. Consequently, they might contain more JS and less, if any, HTML markup. We probably don't need to utilize ShadowDOM as no styles are involved.</p>
<p>Last but not least, there are <strong>build-in components</strong>, which is every build-in HTMLElement like the HTMLButtonElement. They are solely controllable and styleable from the outside and must therefore wrapped in presentational components and/or containers.</p>
<p>Lets start the service description top-down beginning with the <strong>root container</strong> managing the overall service.</p>
<h3 id="root-container">Root container</h3>
<p>The root container <code>shop-checkout</code> is basically just an encapsulation layer in terms of service functionalities. Encapsulation of CSS won't be necessary at this point as no styling is involved. On initialization the <code>shop-checkout</code> might perform following tasks:</p>
<ol type="1">
<li>Importing child components with <strong>HTML Imports</strong></li>
<li>Initialize the service in a logical top to bottom order like in the snippet above</li>
<li>Initializing a <strong>model thread</strong> with <code>new Worker('checkout-model.js')</code>;</li>
<li>Setting up a <code>postMessage</code> stub to dispatch messages to the model</li>
<li>Setting up an event listener for messages from the model</li>
<li>Setting up an event listener for <strong>custom events</strong> from the child nodes</li>
</ol>
<p>On runtime the root container acts mostly like a <strong>message dispatcher</strong> implementing the microservice idea of smart endpoints and dumb pipes.</p>
<p>Every custom child node is eligible aggregate subordinate events from their children, buffer them and interact with the model trough via a <strong>dumb message system</strong>. To talk to the model any child node can dispatch a <strong>unified event containing a unified message object</strong> like the following example illustrates:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Within every child node class</span>
set <span class="at">dispatch</span>(msg) <span class="op">{</span>
  <span class="kw">this</span>.<span class="at">dispatchEvent</span>(
    <span class="kw">new</span> <span class="at">CustomEvent</span>(<span class="st">&#39;checkout&#39;</span><span class="op">,</span> <span class="op">{</span>
      <span class="dt">bubbles</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
      <span class="dt">detail</span><span class="op">:</span> msg
    <span class="op">}</span>)<span class="op">;</span>
  )<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Calling <code>this.dispatch(msg)</code> within a child node will trigger an event bubbling upstream. The service root will implement a simple event listener for <code>checkout</code> events. In a second step the service root add information about the original target (like <em>tag-name#id.className</em>) to the message so the message can be processed in the model thread and eventually pushed back correctly to the sender.</p>
<p>Summarizing the unidirectional model-view communication from the service root perspective looks like following sketch:</p>
<pre><code>VIEW thread         |           MODEL thread
                    |
Checkout ------Event Msg---------&gt;    Msg
  Event             |                Handler
                    |                   |
                    |                Effect
                    |                   |
  Msg               |                Postmessage
Handler &lt;-----Action Msg----------    Action
                    |                   
                    |</code></pre>
<p>Effects are yielded by the asynchronous operation of messages and create actions returned to sender. Effects can be created by external messages, like subscription to an WebSocket, too. Effects may be created with additional resources from the server or syncing with local storage like in the polymer-shop.</p>
<p>While the msg handlers are basic &quot;dumb&quot; switches the <strong>smartness</strong> solely arouse from intelligent controllers processing the message. Every component must implement a <strong>unified socket</strong> in it's service contracts like a property on the custom element:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Within every child node class</span>
set <span class="at">receive</span>(msg) <span class="op">{</span>
  <span class="co">// do something smart</span>
<span class="op">}</span></code></pre></div>
<p>This communication flow is designed to <strong>fail graceful</strong> as simply nothing happens if one or another switch is not defined. Furthermore it incorporates lots of possibilities for <strong>evolutionary design</strong> as child nodes can be loosely dropped in or teared apart. Middleware container wrappers can be pulled in between child nodes and service root to do some extra work and and even the message object can be enhanced freely as long as it won't break with the message conventions. Changing or enhancing any functionality requires only to touch the controllers in the child nodes in question and the endpoint section at the model. Furthermore, <strong>infrastructure automation</strong> might be achieved by dynamically evaluating the mounted child nodes and registering the &quot;backend&quot; model switches on build time. Due to it's standardized message system the components are testable within standardized tests.</p>
<p>To work in a larger scale, we might define a base component which has the default message and socket properties in its guts and extend every new element from this base class.</p>
<p>Another yet more powerful approach can be achieved by calculating the new shape of the DOM in the worker directly and just patch the DOM in the view layer.<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a> This approach is certainly more complicated but worth to evaluate further more.</p>
<h3 id="presentational-components">Presentational components</h3>
<h1 id="thinking-further">Thinking further</h1>
<p>cohesive HTML JS CSS</p>
<p>Most obvious ist the gathering of all related code under the umbrellar of a single HTML tag.</p>
<p>Secondly, the sub-standard <em>custom elements</em> introduces so called lifecycle methods and a getter/setter interface exposing the functionality to the developer. Event handling, for example, can be registered in place which is much more declarative than assigning event listeners from the outside. Of course, this events can be pushed down to nested tags, allowing an increasingly granular system design. This approach will be explained further in the upcoming sections.</p>
<p>Following this logic any company, whether it is web-related or not, should be devided in units grouped around a destinct business service to optimise the workflow. Fowler and Lewis outlines this approach as an &quot;alignment of business capabilities&quot;<span class="citation" data-cites="Fowler2014">(Fowler and Lewis 2014)</span> While this kind of structure may be true for companies like Google or Amazon, there is a vast majority of companies developing for the web which are grouped around tasks.<span class="citation" data-cites="Issa2016">(Issa 2016)</span> A very common structure is formed by the technology stack (UX Designers, Frontend- &amp; Backend Developers) or by separating teams along the product lifecycle (development, testing, deployment).</p>
<p>Advocators from the microservice approach propose a different model. best described by . Web components are one (but important) way to tie up those diciplines as one component can host a single independent business service. Combined with a flexible backend service these components can be huge gain over the cumbersome functional organizational approach.</p>
<p>dichotome Pattern</p>
<p>Ein üblicher eventgesteuerter Webservice setzt sich aus unterschiedlichsten Komponenten zusammen, die wiederum unterschiedlichste Eventlistener &amp; -emitter in sich subsummieren. Diese inhärente Komplexität verlangt geradezu nach einer klaren, deterministischen Struktur des Webservices, die das Zusammenspiel orchestriert. In der Analogie des Orchesters gesprochen, benötigt der Webservice (oder sogar die gesamte Webapplikation) einen Dirigenten, der für die Steuerung verantwortlich ist.</p>
<p>http://alistair.cockburn.us/Hexagonal+architecture</p>
<p>MVC Pattern</p>
<p>Pure frontend vs heavy backend</p>
<div id="refs" class="references">
<div id="ref-Abramov2015">
<p>Abramov, Dan. 2015. “Presentational and Container Components – Medium.” <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" class="uri">https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0</a>.</p>
</div>
<div id="ref-Baldwin2006">
<p>Baldwin, Carliss Y, and Kim B Clark. 2006. “Modularity in the Design of Complex Engineering Systems.” In <em>Complex Engineered Systems: Science Meets Technology</em>, edited by Dan Braha, Ali A Minai, and Yaneer Bar-Yam, 175–205. Berlin, Heidelberg: Springer Berlin Heidelberg. doi:<a href="https://doi.org/10.1007/3-540-32834-3_9">10.1007/3-540-32834-3_9</a>.</p>
</div>
<div id="ref-Bidelman2010">
<p>Bidelman, Eric. 2010. “The Basics of Web Workers.” <a href="https://www.html5rocks.com/en/tutorials/workers/basics/" class="uri">https://www.html5rocks.com/en/tutorials/workers/basics/</a>.</p>
</div>
<div id="ref-Bidelman2016">
<p>———. 2016a. “Custom elements v1: reusable web components.” <a href="https://developers.google.com/web/fundamentals/primers/customelements/" class="uri">https://developers.google.com/web/fundamentals/primers/customelements/</a>.</p>
</div>
<div id="ref-Bidelman2016shadow">
<p>———. 2016b. “Shadow Dom V1: Self-Contained Web Components.” <a href="https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom" class="uri">https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom</a>.</p>
</div>
<div id="ref-Buchner2016">
<p>Buchner, Daniel. 2016. “Demythstifying Web Components.” <a href="http://www.backalleycoder.com/2016/08/26/demythstifying-web-components/" class="uri">http://www.backalleycoder.com/2016/08/26/demythstifying-web-components/</a>.</p>
</div>
<div id="ref-Conway1968">
<p>Conway, Melvin E. 1968. “How Do Committees Invent?” <a href="http://www.melconway.com/Home/Committees_Paper.html" class="uri">http://www.melconway.com/Home/Committees_Paper.html</a>.</p>
</div>
<div id="ref-Filloux2016">
<p>Filloux, Frederic. 2016. “Bloated Html, the Best and the Worse.” <a href="https://mondaynote.com/bloated-html-the-best-and-the-worse-cac6eb06496d" class="uri">https://mondaynote.com/bloated-html-the-best-and-the-worse-cac6eb06496d</a>.</p>
</div>
<div id="ref-Fowler2014">
<p>Fowler, Martin, and James Lewis. 2014. “Microservices: A Definition of This New Architectural Term,” January. <a href="http://www.martinfowler.com/articles/microservices.html" class="uri">http://www.martinfowler.com/articles/microservices.html</a>.</p>
</div>
<div id="ref-HTML">
<p><em>HTML Living Standard — Last Updated 11 January 2017</em>. n.d. <a href="https://html.spec.whatwg.org/multipage/" class="uri">https://html.spec.whatwg.org/multipage/</a>.</p>
</div>
<div id="ref-Issa2016">
<p>Issa, Ben. 2016. “The Way of the Web.” Polymer Summit 2016. <a href="https://www.youtube.com/watch?v=8ZTFEhPBJEE" class="uri">https://www.youtube.com/watch?v=8ZTFEhPBJEE</a>.</p>
</div>
<div id="ref-vanKesteren2014">
<p>Kesteren, Anne van. 2014. “Mozilla and Web Components: Update.” <a href="https://hacks.mozilla.org/2014/12/mozilla-and-web-components/" class="uri">https://hacks.mozilla.org/2014/12/mozilla-and-web-components/</a>.</p>
</div>
<div id="ref-Lawson2016">
<p>Lawson, Nolan. 2016. “Progressive Enhancement Isn’t Dead, but It Smells Funny.” <a href="https://nolanlawson.com/2016/10/13/progressive-enhancement-isnt-dead-but-it-smells-funny/" class="uri">https://nolanlawson.com/2016/10/13/progressive-enhancement-isnt-dead-but-it-smells-funny/</a>.</p>
</div>
<div id="ref-Martin">
<p>Martin, Robert C. n.d. “The Single Responsibility Principle.” <a href="http://programmer.97things.oreilly.com/wiki/index.php/The_Single_Responsibility_Principle" class="uri">http://programmer.97things.oreilly.com/wiki/index.php/The_Single_Responsibility_Principle</a>.</p>
</div>
<div id="ref-Newman2015">
<p>Newman, Sam. 2016. <em>Building Microservices</em>. O’Reilly Media, Inc. <a href="http://www.ebook.de/de/product/22539693/sam_newmann_building_microservices.html" class="uri">http://www.ebook.de/de/product/22539693/sam_newmann_building_microservices.html</a>.</p>
</div>
<div id="ref-Rauschmayer2015">
<p>Rauschmayer, Dr. Axel. 2015. “Tree-Shaking with Webpack 2 and Babel 6.” <a href="http://www.2ality.com/2015/12/webpack-tree-shaking.html" class="uri">http://www.2ality.com/2015/12/webpack-tree-shaking.html</a>.</p>
</div>
<div id="ref-Rota2015">
<p>Rota, Andrew. 2015. “React.js Conf 2015 - the Complementarity of React and Web Components.” <a href="https://www.youtube.com/watch?t=124&amp;v=g0TD0efcwVg" class="uri">https://www.youtube.com/watch?t=124&amp;v=g0TD0efcwVg</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://www.youtube.com/watch?v=rI8tNMsozo0&amp;t=46s">Rails Conf 2012 Keynote: Simplicity Matters by Rich Hickey</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="http://www.etymonline.com/index.php?term=simple">Etymology Dictionary</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="http://httparchive.org/trends.php">HTTPArchive Trends</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="https://extensiblewebmanifesto.org/">The Extensible Web Manifesto</a><a href="#fnref4">↩</a></p></li>
<li id="fn5"><p><a href="http://jonrimmer.github.io/are-we-componentized-yet/">Are we componentized yet?</a><a href="#fnref5">↩</a></p></li>
<li id="fn6"><p><a href="https://developers.google.com/web/progressive-web-apps">Progressive Web Apps</a><a href="#fnref6">↩</a></p></li>
<li id="fn7"><p><a href="https://www.nativescript.org">NativeScript</a><a href="#fnref7">↩</a></p></li>
<li id="fn8"><p><a href="https://webcomponents.org">Webcomponents.org</a><a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Latency numbers: https://gist.github.com/jboner/2841832<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p><a href="http://graphql.org/">GraphQL</a><a href="#fnref10">↩</a></p></li>
<li id="fn11"><p><a href="http://www.datomic.com/">Datomic</a><a href="#fnref11">↩</a></p></li>
<li id="fn12"><p><a href="https://www.polymer-project.org/1.0/toolbox/server">PRLP pattern</a><a href="#fnref12">↩</a></p></li>
<li id="fn13"><p><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">JavaScript Classes</a><a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>https://github.com/w3c/webcomponents/issues/509<a href="#fnref14">↩</a></p></li>
<li id="fn15"><p>https://hacks.mozilla.org/2014/12/mozilla-and-web-components/<a href="#fnref15">↩</a></p></li>
<li id="fn16"><p><a href="https://docs.google.com/document/d/1M9FmT05Q6qpsjgvH1XvCm840yn2eWEg0PMskSQz7k4E">Angular 2 Rendering Architecture</a><a href="#fnref16">↩</a></p></li>
<li id="fn17"><p>A good example of this approach can be found at <a href="http://www.pocketjavascript.com/blog/2015/11/23/introducing-pokedex-org">Introducing Pokedex</a><a href="#fnref17">↩</a></p></li>
</ol>
</section>
</div>
</body>
</html>
